{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though elementary in its structure, provides a substantial basis for studying foundational physical laws. The investigation of how a projectile's range depends on the angle of projection brings together both theoretical and practical insights. This exploration involves not only basic trigonometry and calculus but also reflects a wide variety of real-world applications ranging from sports to aerospace dynamics. 1. Theoretical Foundation Projectile motion can be described by Newton's second law and the kinematic equations. Assuming no air resistance, the only force acting on the object (after it's projected) is gravity. Governing Equations The equations of motion in the x and y directions can be derived from: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow x(t) = v_0 \\cos(\\theta) t \\] \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Launch angle - \\( g \\) : Acceleration due to gravity (9.81 m/s\u00b2) - \\( t \\) : Time Time of Flight The time at which the projectile returns to the same vertical level is: $$ T = \\frac{2v_0\\sin(\\theta)}{g} $$ Range The horizontal range ( \\(R\\) ) of the projectile is given by: $$ R = \\frac{v_0^2\\sin(2\\theta)}{g} $$ This shows the range is maximum when $$ \\theta = 45^\\circ $$. 2. Analysis of the Range The horizontal range varies as a function of the angle of projection: At \\( \\(\\theta = 0^\\circ\\) \\) or \\( \\(\\theta = 90^\\circ\\) \\) , range is zero. Maximum range occurs at \\( \\(45^\\circ\\) \\) Range is symmetric about \\( \\(45^\\circ\\) \\) Influence of Parameters: Initial velocity : Quadratically proportional to range. Gravity : Inversely proportional to range. Angle : Influences both the vertical and horizontal motion. 3. Practical Applications Sports : Understanding how to optimize angle and force for maximum throw or jump. Ballistics : Predicting the path of projectiles with drag. Engineering : Simulations of component launches or material drops. Astrophysics : Modeling the launch paths of satellites with corrections. 4. Implementation in Python Below is Python code to simulate projectile motion with different angles and velocities. A. Plot for 50 m/s and Angles 15, 45, 75 Degrees import numpy as np import matplotlib.pyplot as plt def projectile(v0, theta_deg): g = 9.81 theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y angles = [15, 45, 75] plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(50, angle) plt.plot(x, y, label=f'{angle}\\u00b0') plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show() B. Plot for Velocities 30, 40, 50 m/s at 45 Degrees velocities = [30, 40, 50] plt.figure(figsize=(10,6)) for v in velocities: x, y = projectile(v, 45) plt.plot(x, y, label=f'{v} m/s') plt.title('Projectile Motion for Different Velocities (45 Degrees)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show() Range Visualization and Effects These plots visually confirm: - Greater velocity leads to higher and farther motion. - Angle significantly affects maximum height and range. Limitations and Extensions This model does not account for: - Air resistance : Causes asymmetry and shorter range. - Wind : Alters trajectory path. - Launch height : If not from ground level, modifies equations. Extensions can include solving differential equations with drag force: $$ \\vec{F} = -kv\\vec{v} \\quad \\text{(linear drag)} $$","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though elementary in its structure, provides a substantial basis for studying foundational physical laws. The investigation of how a projectile's range depends on the angle of projection brings together both theoretical and practical insights. This exploration involves not only basic trigonometry and calculus but also reflects a wide variety of real-world applications ranging from sports to aerospace dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion can be described by Newton's second law and the kinematic equations. Assuming no air resistance, the only force acting on the object (after it's projected) is gravity.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The equations of motion in the x and y directions can be derived from: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow x(t) = v_0 \\cos(\\theta) t \\] \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Launch angle - \\( g \\) : Acceleration due to gravity (9.81 m/s\u00b2) - \\( t \\) : Time","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The time at which the projectile returns to the same vertical level is: $$ T = \\frac{2v_0\\sin(\\theta)}{g} $$","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"The horizontal range ( \\(R\\) ) of the projectile is given by: $$ R = \\frac{v_0^2\\sin(2\\theta)}{g} $$ This shows the range is maximum when $$ \\theta = 45^\\circ $$.","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range varies as a function of the angle of projection: At \\( \\(\\theta = 0^\\circ\\) \\) or \\( \\(\\theta = 90^\\circ\\) \\) , range is zero. Maximum range occurs at \\( \\(45^\\circ\\) \\) Range is symmetric about \\( \\(45^\\circ\\) \\)","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial velocity : Quadratically proportional to range. Gravity : Inversely proportional to range. Angle : Influences both the vertical and horizontal motion.","title":"Influence of Parameters:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Understanding how to optimize angle and force for maximum throw or jump. Ballistics : Predicting the path of projectiles with drag. Engineering : Simulations of component launches or material drops. Astrophysics : Modeling the launch paths of satellites with corrections.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"Below is Python code to simulate projectile motion with different angles and velocities.","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-plot-for-50-ms-and-angles-15-45-75-degrees","text":"import numpy as np import matplotlib.pyplot as plt def projectile(v0, theta_deg): g = 9.81 theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y angles = [15, 45, 75] plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(50, angle) plt.plot(x, y, label=f'{angle}\\u00b0') plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show()","title":"A. Plot for 50 m/s and Angles 15, 45, 75 Degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-plot-for-velocities-30-40-50-ms-at-45-degrees","text":"velocities = [30, 40, 50] plt.figure(figsize=(10,6)) for v in velocities: x, y = projectile(v, 45) plt.plot(x, y, label=f'{v} m/s') plt.title('Projectile Motion for Different Velocities (45 Degrees)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show()","title":"B. Plot for Velocities 30, 40, 50 m/s at 45 Degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-visualization-and-effects","text":"These plots visually confirm: - Greater velocity leads to higher and farther motion. - Angle significantly affects maximum height and range.","title":"Range Visualization and Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"This model does not account for: - Air resistance : Causes asymmetry and shorter range. - Wind : Alters trajectory path. - Launch height : If not from ground level, modifies equations. Extensions can include solving differential equations with drag force: $$ \\vec{F} = -kv\\vec{v} \\quad \\text{(linear drag)} $$","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating dynamical system that demonstrates a wide range of behaviors from simple harmonic motion to complex chaos. This transition occurs due to the interplay between natural oscillatory forces, damping mechanisms, and external periodic forces. This system provides a classical example for studying phenomena like resonance, energy dissipation, and chaotic dynamics, which are prevalent in many real-world systems such as suspension bridges, climate oscillations, and electronic circuits. 1. Theoretical Foundation We begin with the second-order nonlinear differential equation governing a forced damped pendulum: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement - \\(b\\) is the damping coefficient - \\(g\\) is the gravitational acceleration - \\(L\\) is the length of the pendulum - \\(A\\) is the amplitude of the external forcing - \\(\\omega\\) is the driving frequency Small-Angle Approximation For small oscillations, \\(\\sin(\\theta) \\approx \\theta\\) , and the equation simplifies to: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear differential equation that resembles the driven damped harmonic oscillator. 2. Analysis of Dynamics Pure Pendulum (No damping or forcing) \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = 0 \\] Damped Pendulum (With damping, no forcing) \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = 0 \\] Driven Undamped Pendulum (With forcing, no damping) \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Forced Damped Pendulum (Full model) \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] 3. Practical Applications Mechanical Engineering : Suspension systems, rotating machinery Electrical Engineering : Analogies to driven RLC circuits Biomechanics : Modeling of human gait or limb movements under periodic stimulus Climate Science : Oscillatory climate models (e.g., El Nino cycles) 4. Implementation We use Python to simulate the system dynamics using the Runge-Kutta method. We visualize the angle vs. time, phase portraits, and explore chaotic behavior and resonance. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of external force omega = 2/3 # frequency of external force def pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.2, 0.0] # initial angle and angular velocity t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot Angle vs. Time plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol.t, sol.y[0]) plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') # Phase Portrait plt.subplot(1, 2, 2) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() Advanced Analysis We can extend the model further to include: - Poincar\u00e9 Sections : by sampling state variables at intervals of the driving period - Bifurcation Diagrams : by sweeping over \\(A\\) or \\(\\omega\\) - Lyapunov Exponents : to detect chaotic dynamics Conclusion The forced damped pendulum is a powerful model capturing fundamental and complex behavior in physics. Through theoretical derivations and computational simulations, we observe transitions from order to chaos, and understand deeper mechanisms underlying many real-world dynamic systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating dynamical system that demonstrates a wide range of behaviors from simple harmonic motion to complex chaos. This transition occurs due to the interplay between natural oscillatory forces, damping mechanisms, and external periodic forces. This system provides a classical example for studying phenomena like resonance, energy dissipation, and chaotic dynamics, which are prevalent in many real-world systems such as suspension bridges, climate oscillations, and electronic circuits.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We begin with the second-order nonlinear differential equation governing a forced damped pendulum: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement - \\(b\\) is the damping coefficient - \\(g\\) is the gravitational acceleration - \\(L\\) is the length of the pendulum - \\(A\\) is the amplitude of the external forcing - \\(\\omega\\) is the driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, \\(\\sin(\\theta) \\approx \\theta\\) , and the equation simplifies to: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear differential equation that resembles the driven damped harmonic oscillator.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pure-pendulum-no-damping-or-forcing","text":"\\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = 0 \\]","title":"Pure Pendulum (No damping or forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum-with-damping-no-forcing","text":"\\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = 0 \\]","title":"Damped Pendulum (With damping, no forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driven-undamped-pendulum-with-forcing-no-damping","text":"\\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\]","title":"Driven Undamped Pendulum (With forcing, no damping)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-full-model","text":"\\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\]","title":"Forced Damped Pendulum (Full model)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Mechanical Engineering : Suspension systems, rotating machinery Electrical Engineering : Analogies to driven RLC circuits Biomechanics : Modeling of human gait or limb movements under periodic stimulus Climate Science : Oscillatory climate models (e.g., El Nino cycles)","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We use Python to simulate the system dynamics using the Runge-Kutta method. We visualize the angle vs. time, phase portraits, and explore chaotic behavior and resonance.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of external force omega = 2/3 # frequency of external force def pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.2, 0.0] # initial angle and angular velocity t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot Angle vs. Time plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol.t, sol.y[0]) plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') # Phase Portrait plt.subplot(1, 2, 2) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#advanced-analysis","text":"We can extend the model further to include: - Poincar\u00e9 Sections : by sampling state variables at intervals of the driving period - Bifurcation Diagrams : by sweeping over \\(A\\) or \\(\\omega\\) - Lyapunov Exponents : to detect chaotic dynamics","title":"Advanced Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum is a powerful model capturing fundamental and complex behavior in physics. Through theoretical derivations and computational simulations, we observe transitions from order to chaos, and understand deeper mechanisms underlying many real-world dynamic systems.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Derivation, Simulation, and Application of Kepler's Third Law 1. Introduction The relationship between the orbital period \\(T\\) and the orbital radius \\(r\\) of celestial bodies is described by Kepler's Third Law . It was later derived using Newton's Law of Gravitation , providing a deep connection between gravity and orbital motion. In this document, we: - Derive the relationship mathematically, - Simulate the relation using planetary data, - Calculate the mass of the Earth and Sun using Kepler\u2019s Law, - Discuss the law's application to elliptical orbits. 2. Derivation of Kepler\u2019s Third Law for Circular Orbits Starting with Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] The centripetal force needed for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal (gravity provides centripetal force): \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) relates to velocity \\(v\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\] 3. Simulation and Plotting \\(T^2\\) vs \\(r^3\\) We verify the relationship using planetary data (Mercury, Venus, Earth, Mars). 3.1 Python Code # Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_AU = np.array([0.387, 0.723, 1.000, 1.524]) # Orbital radii (AU) T_years = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital periods (years) # Compute r^3 and T^2 r_cubed = r_AU**3 T_squared = T_years**2 # Plotting plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='blue', markersize=8) for i, planet in enumerate(planets): plt.text(r_cubed[i]*1.02, T_squared[i]*0.98, planet, fontsize=10) plt.xlabel(r\"$r^3$ (AU$^3$)\", fontsize=14) plt.ylabel(r\"$T^2$ (years$^2$)\", fontsize=14) plt.title(r\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=16) plt.grid(True) plt.show() 3.2 Interpretation The plot of \\(T^2\\) against \\(r^3\\) is a straight line , confirming that \\(T^2 \\propto r^3\\) . This matches the theoretical derivation and validates Kepler\u2019s Third Law . 4. Applications: Mass Calculations 4.1 Finding the Mass of the Sun Using Earth's orbit: Orbital radius: \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) Orbital period: \\(T = 3.154 \\times 10^{7}\\ \\text{s}\\) The mass of the Sun is given by: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] where \\(G = 6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . Code to Find Mass of Sun # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) r_earth = 1.496e11 # Orbital radius of Earth (m) T_earth = 3.154e7 # Orbital period of Earth (s) # Calculate Mass of Sun M_sun = (4 * np.pi**2 * r_earth**3) / (G * T_earth**2) print(f\"Mass of the Sun = {M_sun:.3e} kg\") Result: Mass of the Sun \\(\\approx 1.99 \\times 10^{30}\\ \\text{kg}\\) 4.2 Finding the Mass of the Earth Using the Moon's orbit: Orbital radius: \\(r = 3.844 \\times 10^{8}\\ \\text{m}\\) Orbital period: \\(T = 2.3606 \\times 10^{6}\\ \\text{s}\\) Code to Find Mass of Earth # Moon orbit data r_moon = 3.844e8 # Orbital radius of Moon (m) T_moon = 2.3606e6 # Orbital period of Moon (s) # Calculate Mass of Earth M_earth = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Mass of the Earth = {M_earth:.3e} kg\") Result: Mass of the Earth \\(\\approx 5.97 \\times 10^{24}\\ \\text{kg}\\) 5. Extension: Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law becomes: \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] where \\(a\\) is the semi-major axis of the ellipse. Thus, \\(T^2\\) is proportional to \\(a^3\\) even for non-circular (elliptical) orbits.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-simulation-and-application-of-keplers-third-law","text":"","title":"Derivation, Simulation, and Application of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-introduction","text":"The relationship between the orbital period \\(T\\) and the orbital radius \\(r\\) of celestial bodies is described by Kepler's Third Law . It was later derived using Newton's Law of Gravitation , providing a deep connection between gravity and orbital motion. In this document, we: - Derive the relationship mathematically, - Simulate the relation using planetary data, - Calculate the mass of the Earth and Sun using Kepler\u2019s Law, - Discuss the law's application to elliptical orbits.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-derivation-of-keplers-third-law-for-circular-orbits","text":"Starting with Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] The centripetal force needed for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal (gravity provides centripetal force): \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) relates to velocity \\(v\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\]","title":"2. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-simulation-and-plotting-t2-vs-r3","text":"We verify the relationship using planetary data (Mercury, Venus, Earth, Mars).","title":"3. Simulation and Plotting \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-python-code","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_AU = np.array([0.387, 0.723, 1.000, 1.524]) # Orbital radii (AU) T_years = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital periods (years) # Compute r^3 and T^2 r_cubed = r_AU**3 T_squared = T_years**2 # Plotting plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='blue', markersize=8) for i, planet in enumerate(planets): plt.text(r_cubed[i]*1.02, T_squared[i]*0.98, planet, fontsize=10) plt.xlabel(r\"$r^3$ (AU$^3$)\", fontsize=14) plt.ylabel(r\"$T^2$ (years$^2$)\", fontsize=14) plt.title(r\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=16) plt.grid(True) plt.show()","title":"3.1 Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-interpretation","text":"The plot of \\(T^2\\) against \\(r^3\\) is a straight line , confirming that \\(T^2 \\propto r^3\\) . This matches the theoretical derivation and validates Kepler\u2019s Third Law .","title":"3.2 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-applications-mass-calculations","text":"","title":"4. Applications: Mass Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-finding-the-mass-of-the-sun","text":"Using Earth's orbit: Orbital radius: \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) Orbital period: \\(T = 3.154 \\times 10^{7}\\ \\text{s}\\) The mass of the Sun is given by: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] where \\(G = 6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) .","title":"4.1 Finding the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-to-find-mass-of-sun","text":"# Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) r_earth = 1.496e11 # Orbital radius of Earth (m) T_earth = 3.154e7 # Orbital period of Earth (s) # Calculate Mass of Sun M_sun = (4 * np.pi**2 * r_earth**3) / (G * T_earth**2) print(f\"Mass of the Sun = {M_sun:.3e} kg\") Result: Mass of the Sun \\(\\approx 1.99 \\times 10^{30}\\ \\text{kg}\\)","title":"Code to Find Mass of Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-finding-the-mass-of-the-earth","text":"Using the Moon's orbit: Orbital radius: \\(r = 3.844 \\times 10^{8}\\ \\text{m}\\) Orbital period: \\(T = 2.3606 \\times 10^{6}\\ \\text{s}\\)","title":"4.2 Finding the Mass of the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-to-find-mass-of-earth","text":"# Moon orbit data r_moon = 3.844e8 # Orbital radius of Moon (m) T_moon = 2.3606e6 # Orbital period of Moon (s) # Calculate Mass of Earth M_earth = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Mass of the Earth = {M_earth:.3e} kg\") Result: Mass of the Earth \\(\\approx 5.97 \\times 10^{24}\\ \\text{kg}\\)","title":"Code to Find Mass of Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law becomes: \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] where \\(a\\) is the semi-major axis of the ellipse. Thus, \\(T^2\\) is proportional to \\(a^3\\) even for non-circular (elliptical) orbits.","title":"5. Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape and Cosmic Velocities Introduction Cosmic velocities define the speed thresholds required to: Stay in orbit \u2013 First Cosmic Velocity Escape the planet's gravity \u2013 Second Cosmic Velocity Escape the solar system \u2013 Third Cosmic Velocity These principles are fundamental in spaceflight mechanics and interplanetary mission planning. 1. Derivation of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the minimum speed needed to orbit a celestial body near its surface in a circular orbit. From Newton\u2019s gravitational force and centripetal force balance: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Second Cosmic Velocity ( \\(v_2\\) ) This is the escape velocity , i.e., the velocity needed to completely escape the gravitational field of a planet. From conservation of energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Therefore: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Third Cosmic Velocity ( \\(v_3\\) ) This is the minimum speed required to escape the Sun's gravitational pull from Earth\u2019s orbit. Using Pythagoras-like relation: \\[ v_3 = \\sqrt{v_{\\text{esc, Earth}}^2 + v_{\\text{orbit around Sun}}^2} \\] Where: - \\(v_{\\text{esc, Earth}} \\approx 11.2 \\, \\text{km/s}\\) - \\(v_{\\text{orbit around Sun}} \\approx 29.78 \\, \\text{km/s}\\) Then: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (29.78)^2} \\approx 42.1 \\, \\text{km/s} \\] 2. Earth Cosmic Velocity Values Velocity Type Formula Value (Earth) First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\(\\approx 7.91\\) km/s Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\(\\approx 11.2\\) km/s Third Cosmic Velocity \\(v_3 = \\sqrt{v_1^2 + v_{\\text{orbit}}^2}\\) \\(\\approx 42.1\\) km/s 3. Comparison with Moon, Mars, Jupiter import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Mass (kg) and Radius (m) for each body bodies = { \"Moon\": [7.35e22, 1.74e6], \"Earth\": [5.97e24, 6.37e6], \"Mars\": [6.42e23, 3.39e6], \"Jupiter\": [1.90e27, 6.99e7] } # Calculate v1 and v2 for each body results = {} for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v2 = np.sqrt(2 * G * M / R) / 1000 results[name] = (v1, v2) # Prepare data labels = list(results.keys()) v1_vals = [results[body][0] for body in labels] v2_vals = [results[body][1] for body in labels] # Plot x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') ax.bar(x + width/2, v2_vals, width, label='v2 (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Summary Table Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(\\approx 1.68\\) \\(\\approx 2.38\\) Earth \\(\\approx 7.91\\) \\(\\approx 11.2\\) Mars \\(\\approx 3.55\\) \\(\\approx 5.02\\) Jupiter \\(\\approx 42.0\\) \\(\\approx 59.5\\) Applications in Space Science \\(v_1\\) : Needed for low-Earth orbit satellites (e.g., ISS). \\(v_2\\) : Required for missions to the Moon, Mars, or other planets. \\(v_3\\) : Needed for deep-space probes like Voyager or Pioneer missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-and-cosmic-velocities","text":"","title":"Escape and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Cosmic velocities define the speed thresholds required to: Stay in orbit \u2013 First Cosmic Velocity Escape the planet's gravity \u2013 Second Cosmic Velocity Escape the solar system \u2013 Third Cosmic Velocity These principles are fundamental in spaceflight mechanics and interplanetary mission planning.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-derivation-of-cosmic-velocities","text":"","title":"1. Derivation of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the minimum speed needed to orbit a celestial body near its surface in a circular orbit. From Newton\u2019s gravitational force and centripetal force balance: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"This is the escape velocity , i.e., the velocity needed to completely escape the gravitational field of a planet. From conservation of energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Therefore: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the minimum speed required to escape the Sun's gravitational pull from Earth\u2019s orbit. Using Pythagoras-like relation: \\[ v_3 = \\sqrt{v_{\\text{esc, Earth}}^2 + v_{\\text{orbit around Sun}}^2} \\] Where: - \\(v_{\\text{esc, Earth}} \\approx 11.2 \\, \\text{km/s}\\) - \\(v_{\\text{orbit around Sun}} \\approx 29.78 \\, \\text{km/s}\\) Then: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (29.78)^2} \\approx 42.1 \\, \\text{km/s} \\]","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-earth-cosmic-velocity-values","text":"Velocity Type Formula Value (Earth) First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\(\\approx 7.91\\) km/s Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\(\\approx 11.2\\) km/s Third Cosmic Velocity \\(v_3 = \\sqrt{v_1^2 + v_{\\text{orbit}}^2}\\) \\(\\approx 42.1\\) km/s","title":"2. Earth Cosmic Velocity Values"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-comparison-with-moon-mars-jupiter","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Mass (kg) and Radius (m) for each body bodies = { \"Moon\": [7.35e22, 1.74e6], \"Earth\": [5.97e24, 6.37e6], \"Mars\": [6.42e23, 3.39e6], \"Jupiter\": [1.90e27, 6.99e7] } # Calculate v1 and v2 for each body results = {} for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v2 = np.sqrt(2 * G * M / R) / 1000 results[name] = (v1, v2) # Prepare data labels = list(results.keys()) v1_vals = [results[body][0] for body in labels] v2_vals = [results[body][1] for body in labels] # Plot x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') ax.bar(x + width/2, v2_vals, width, label='v2 (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"3. Comparison with Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-table","text":"Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(\\approx 1.68\\) \\(\\approx 2.38\\) Earth \\(\\approx 7.91\\) \\(\\approx 11.2\\) Mars \\(\\approx 3.55\\) \\(\\approx 5.02\\) Jupiter \\(\\approx 42.0\\) \\(\\approx 59.5\\)","title":"Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications-in-space-science","text":"\\(v_1\\) : Needed for low-Earth orbit satellites (e.g., ISS). \\(v_2\\) : Required for missions to the Moon, Mars, or other planets. \\(v_3\\) : Needed for deep-space probes like Voyager or Pioneer missions.","title":"Applications in Space Science"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Here is a complete academic solution in Markdown format using LaTeX-style dollar signs for all equations. This includes the explanation, physical modeling, and a Python simulation for Problem 3: Payload Trajectories from Near-Earth Orbit . Trajectories of a Freely Released Payload Near Earth Problem Statement We examine the motion of a payload launched from an altitude of 800 km above Earth's surface with various initial velocities. The goal is to determine whether the object falls back, orbits, or escapes Earth depending on initial conditions. 1. Assumptions and Physical Background Earth's Radius : \\(R_E = 6.37 \\times 10^6 \\, \\text{m}\\) Initial altitude : \\(h = 800 \\, \\text{km} = 8.0 \\times 10^5 \\, \\text{m}\\) Total radial distance : \\(r_0 = R_E + h = 7.17 \\times 10^6 \\, \\text{m}\\) Gravitational Parameter : \\(\\mu = G M_E \\approx 3.986 \\times 10^{14} \\, \\text{m}^3/\\text{s}^2\\) Using Newton's law of gravitation, the equation of motion is: \\[ \\vec{a} = -\\frac{GM_E}{r^3} \\vec{r} \\] This second-order differential equation describes how gravity pulls the object toward Earth. The simulation integrates this numerically using time-stepping. 2. Orbital Behavior vs. Velocity Initial velocities tested: \\[ v_0 = [5,\\, 5.5,\\, 6,\\, 6.5,\\, \\ldots,\\, 13] \\, \\text{km/s} \\] These result in: - \\(v < 7.91\\) km/s : Suborbital (falls back) - \\(v = 7.91\\) km/s : Circular orbit - \\(7.91 < v < 11.2\\) km/s : Elliptical orbit - \\(v = 11.2\\) km/s : Escape velocity - \\(v > 11.2\\) km/s : Hyperbolic trajectory 3. Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg mu = G * M # standard gravitational parameter R_earth = 6.37e6 # Earth's radius in meters altitude = 800e3 # altitude in meters r0 = R_earth + altitude # Time setup dt = 1 # time step in seconds T = 10000 # total time steps = int(T / dt) # Initial velocities in m/s v0_list = np.arange(5e3, 13.5e3, 0.5e3) # Plot setup fig, ax = plt.subplots(figsize=(8, 8)) # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_artist(earth) for v0 in v0_list: pos = np.array([r0, 0.0]) vel = np.array([0.0, v0]) trajectory_x = [] trajectory_y = [] for _ in range(steps): r = np.linalg.norm(pos) acc = -mu * pos / r**3 vel += acc * dt pos += vel * dt trajectory_x.append(pos[0]) trajectory_y.append(pos[1]) if r < R_earth: break ax.plot(trajectory_x, trajectory_y, label=f'{v0/1000:.1f} km/s') # Plot formatting ax.set_title('Trajectories of Payload from 800 km Altitude') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_aspect('equal') ax.set_xlim(-1.5e7, 1.5e7) ax.set_ylim(-1.5e7, 1.5e7) ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() 4. Analysis of Results Initial Velocity (km/s) Trajectory Type 5.0\u20137.9 Suborbital 7.91 Circular Orbit 8.0\u201311.1 Elliptical Orbit 11.2 Escape Trajectory 11.5\u201313.0 Hyperbolic Escape 5. Applications and Implications Understanding these trajectories is essential for: Satellite insertion into LEO or GEO Planetary missions (e.g., Mars rovers) Designing return capsules or interstellar probes Conclusion The velocity at which an object is released significantly determines its trajectory: orbital, escape, or fall-back. These principles form the backbone of trajectory planning in space missions and highlight the delicate balance required for orbital mechanics.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Here is a complete academic solution in Markdown format using LaTeX-style dollar signs for all equations. This includes the explanation, physical modeling, and a Python simulation for Problem 3: Payload Trajectories from Near-Earth Orbit .","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-statement","text":"We examine the motion of a payload launched from an altitude of 800 km above Earth's surface with various initial velocities. The goal is to determine whether the object falls back, orbits, or escapes Earth depending on initial conditions.","title":"Problem Statement"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-assumptions-and-physical-background","text":"Earth's Radius : \\(R_E = 6.37 \\times 10^6 \\, \\text{m}\\) Initial altitude : \\(h = 800 \\, \\text{km} = 8.0 \\times 10^5 \\, \\text{m}\\) Total radial distance : \\(r_0 = R_E + h = 7.17 \\times 10^6 \\, \\text{m}\\) Gravitational Parameter : \\(\\mu = G M_E \\approx 3.986 \\times 10^{14} \\, \\text{m}^3/\\text{s}^2\\) Using Newton's law of gravitation, the equation of motion is: \\[ \\vec{a} = -\\frac{GM_E}{r^3} \\vec{r} \\] This second-order differential equation describes how gravity pulls the object toward Earth. The simulation integrates this numerically using time-stepping.","title":"1. Assumptions and Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-orbital-behavior-vs-velocity","text":"Initial velocities tested: \\[ v_0 = [5,\\, 5.5,\\, 6,\\, 6.5,\\, \\ldots,\\, 13] \\, \\text{km/s} \\] These result in: - \\(v < 7.91\\) km/s : Suborbital (falls back) - \\(v = 7.91\\) km/s : Circular orbit - \\(7.91 < v < 11.2\\) km/s : Elliptical orbit - \\(v = 11.2\\) km/s : Escape velocity - \\(v > 11.2\\) km/s : Hyperbolic trajectory","title":"2. Orbital Behavior vs. Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg mu = G * M # standard gravitational parameter R_earth = 6.37e6 # Earth's radius in meters altitude = 800e3 # altitude in meters r0 = R_earth + altitude # Time setup dt = 1 # time step in seconds T = 10000 # total time steps = int(T / dt) # Initial velocities in m/s v0_list = np.arange(5e3, 13.5e3, 0.5e3) # Plot setup fig, ax = plt.subplots(figsize=(8, 8)) # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_artist(earth) for v0 in v0_list: pos = np.array([r0, 0.0]) vel = np.array([0.0, v0]) trajectory_x = [] trajectory_y = [] for _ in range(steps): r = np.linalg.norm(pos) acc = -mu * pos / r**3 vel += acc * dt pos += vel * dt trajectory_x.append(pos[0]) trajectory_y.append(pos[1]) if r < R_earth: break ax.plot(trajectory_x, trajectory_y, label=f'{v0/1000:.1f} km/s') # Plot formatting ax.set_title('Trajectories of Payload from 800 km Altitude') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_aspect('equal') ax.set_xlim(-1.5e7, 1.5e7) ax.set_ylim(-1.5e7, 1.5e7) ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show()","title":"3. Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-analysis-of-results","text":"Initial Velocity (km/s) Trajectory Type 5.0\u20137.9 Suborbital 7.91 Circular Orbit 8.0\u201311.1 Elliptical Orbit 11.2 Escape Trajectory 11.5\u201313.0 Hyperbolic Escape","title":"4. Analysis of Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-applications-and-implications","text":"Understanding these trajectories is essential for: Satellite insertion into LEO or GEO Planetary missions (e.g., Mars rovers) Designing return capsules or interstellar probes","title":"5. Applications and Implications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"The velocity at which an object is released significantly determines its trajectory: orbital, escape, or fall-back. These principles form the backbone of trajectory planning in space missions and highlight the delicate balance required for orbital mechanics.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns from Multiple Wave Sources Overview This document presents a simulation of interference patterns generated by coherent point wave sources located on the vertices of regular polygons. We investigate how the principle of superposition affects wave propagation on a 2D water surface and visualize the resulting waveforms as heatmaps and 3D surface plots . Finally, we produce animated interference videos that capture the wave dynamics over time. 1. Theoretical Background A single wave from a point source is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) at time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source \\((x_0, y_0)\\) , - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase (set to 0 here for simplicity). For \\(N\\) sources at positions \\(\\{(x_i, y_i)\\}\\) , the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . 2. Python Simulation Parameters import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Grid and time x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t_vals = np.linspace(0, 2*np.pi, 60) # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Source configuration: Pentagon def polygon_vertices(N, radius=2): return [(radius * np.cos(2 * np.pi * i / N), radius * np.sin(2 * np.pi * i / N)) for i in range(N)] sources = polygon_vertices(5) # Change to 1, 2, 3... for triangle, square, etc. Wave Function def interference_pattern(X, Y, t, sources): Z = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by zero Z += (A / np.sqrt(R)) * np.cos(k * R - omega * t) return Z 3. Visualization Static 2D and 3D Snapshots # Static at t = 0 Z = interference_pattern(X, Y, t=0, sources=sources) fig = plt.figure(figsize=(12, 5)) # Heatmap ax1 = fig.add_subplot(1, 2, 1) c1 = ax1.imshow(Z, extent=(-5, 5, -5, 5), cmap='seismic') ax1.set_title(\"Heatmap of Interference\") plt.colorbar(c1, ax=ax1) # 3D surface from mpl_toolkits.mplot3d import Axes3D ax2 = fig.add_subplot(1, 2, 2, projection='3d') ax2.plot_surface(X, Y, Z, cmap='viridis', rstride=5, cstride=5) ax2.set_title(\"3D Surface Plot\") plt.tight_layout() plt.show() Animated GIF Creation fig, ax = plt.subplots() im = ax.imshow(np.zeros_like(X), extent=(-5, 5, -5, 5), cmap='seismic', vmin=-3, vmax=3) ax.set_title(\"Wave Interference Animation\") def animate(t): Z = interference_pattern(X, Y, t, sources) im.set_array(Z) return [im] ani = animation.FuncAnimation(fig, animate, frames=t_vals, interval=50, blit=True) ani.save(\"interference.gif\", writer='pillow') 4. Observations and Analysis Single Source : Produces symmetric, concentric waves with uniform intensity loss outward. Two Sources : Creates a clear pattern of nodal (destructive) and antinodal (constructive) lines, known as interference fringes . Multiple Sources (Triangle, Pentagon, etc.) : Introduces complex, symmetric interference patterns with highly structured nodal regions. These become increasingly intricate as the number of sources increases. The coherence of sources ensures stable patterns. Incoherence would blur the interference. 5. Real-World Applications Acoustics : Understanding sound interference in auditoriums. Optics : Multi-slit experiments in wave-particle duality. Telecommunications : Antenna interference and phased arrays. Fluid Mechanics : Wave behavior in oceans and microfluidics. Conclusion This study provides both a mathematical and visual understanding of wave interference using multiple coherent point sources arranged on regular polygons. Such models are foundational for deeper insights in physics and engineering disciplines.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-multiple-wave-sources","text":"","title":"Interference Patterns from Multiple Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#overview","text":"This document presents a simulation of interference patterns generated by coherent point wave sources located on the vertices of regular polygons. We investigate how the principle of superposition affects wave propagation on a 2D water surface and visualize the resulting waveforms as heatmaps and 3D surface plots . Finally, we produce animated interference videos that capture the wave dynamics over time.","title":"Overview"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"A single wave from a point source is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) at time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source \\((x_0, y_0)\\) , - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase (set to 0 here for simplicity). For \\(N\\) sources at positions \\(\\{(x_i, y_i)\\}\\) , the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) .","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-python-simulation","text":"","title":"2. Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Grid and time x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t_vals = np.linspace(0, 2*np.pi, 60) # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Source configuration: Pentagon def polygon_vertices(N, radius=2): return [(radius * np.cos(2 * np.pi * i / N), radius * np.sin(2 * np.pi * i / N)) for i in range(N)] sources = polygon_vertices(5) # Change to 1, 2, 3... for triangle, square, etc.","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-function","text":"def interference_pattern(X, Y, t, sources): Z = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by zero Z += (A / np.sqrt(R)) * np.cos(k * R - omega * t) return Z","title":"Wave Function"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-visualization","text":"","title":"3. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#static-2d-and-3d-snapshots","text":"# Static at t = 0 Z = interference_pattern(X, Y, t=0, sources=sources) fig = plt.figure(figsize=(12, 5)) # Heatmap ax1 = fig.add_subplot(1, 2, 1) c1 = ax1.imshow(Z, extent=(-5, 5, -5, 5), cmap='seismic') ax1.set_title(\"Heatmap of Interference\") plt.colorbar(c1, ax=ax1) # 3D surface from mpl_toolkits.mplot3d import Axes3D ax2 = fig.add_subplot(1, 2, 2, projection='3d') ax2.plot_surface(X, Y, Z, cmap='viridis', rstride=5, cstride=5) ax2.set_title(\"3D Surface Plot\") plt.tight_layout() plt.show()","title":"Static 2D and 3D Snapshots"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#animated-gif-creation","text":"fig, ax = plt.subplots() im = ax.imshow(np.zeros_like(X), extent=(-5, 5, -5, 5), cmap='seismic', vmin=-3, vmax=3) ax.set_title(\"Wave Interference Animation\") def animate(t): Z = interference_pattern(X, Y, t, sources) im.set_array(Z) return [im] ani = animation.FuncAnimation(fig, animate, frames=t_vals, interval=50, blit=True) ani.save(\"interference.gif\", writer='pillow')","title":"Animated GIF Creation"},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"Single Source : Produces symmetric, concentric waves with uniform intensity loss outward. Two Sources : Creates a clear pattern of nodal (destructive) and antinodal (constructive) lines, known as interference fringes . Multiple Sources (Triangle, Pentagon, etc.) : Introduces complex, symmetric interference patterns with highly structured nodal regions. These become increasingly intricate as the number of sources increases. The coherence of sources ensures stable patterns. Incoherence would blur the interference.","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-real-world-applications","text":"Acoustics : Understanding sound interference in auditoriums. Optics : Multi-slit experiments in wave-particle duality. Telecommunications : Antenna interference and phased arrays. Fluid Mechanics : Wave behavior in oceans and microfluidics.","title":"5. Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This study provides both a mathematical and visual understanding of wave interference using multiple coherent point sources arranged on regular polygons. Such models are foundational for deeper insights in physics and engineering disciplines.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism - Problem 1: Simulating the Effects of the Lorentz Force 1. Theoretical Background The Lorentz force equation describes how a charged particle moves under electric and magnetic fields: \\[ \\mathbf{F} = q \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] where: \\(q\\) = particle charge \\(\\mathbf{v}\\) = particle velocity \\(\\mathbf{E}\\) = electric field \\(\\mathbf{B}\\) = magnetic field This fundamental law governs the behavior of particles in systems like: Cyclotrons : Particle accelerators using \\(\\mathbf{B}\\) to bend paths. Mass spectrometers : Measuring \\(m/q\\) by magnetic deflection. Plasma confinement : Tokamaks use \\(\\mathbf{B}\\) to trap plasma. 2. Python Simulation Equations of Motion We numerically integrate Newton\u2019s second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] with: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] We\u2019ll use Euler's method for simplicity. Simulation Code (Python) Here\u2019s the full code simulating: \u2705 Uniform \\(\\mathbf{B}\\) field \u2705 Uniform \\(\\mathbf{E}\\) field \u2705 Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) And 3D trajectory plots ! import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Lorentz force simulation def simulate_lorentz(q, m, E, B, v0, r0, dt, steps): v = np.zeros((steps, 3)) r = np.zeros((steps, 3)) v[0] = v0 r[0] = r0 for i in range(1, steps): F = q * (E + np.cross(v[i-1], B)) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Parameters q = 1.0 # Charge m = 1.0 # Mass E = np.array([0.0, 0.0, 0.0]) # Uniform electric field B = np.array([0.0, 0.0, 1.0]) # Uniform magnetic field (along z) v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position dt = 0.01 steps = 3000 # Run simulation r, v = simulate_lorentz(q, m, E, B, v0, r0, dt, steps) # Plotting 3D trajectory fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(\"Charged Particle Trajectory (Lorentz Force)\") plt.show() Visualization Examples 1\ufe0f Uniform Magnetic Field: Circular Motion Particle orbits in circles (Larmor motion). Radius \\(R = \\frac{mv}{qB}\\) . 2\ufe0f Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) : Drift Motion Drift velocity: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] 3\ufe0f Uniform \\(\\mathbf{E}\\) Field: Acceleration Linear acceleration along \\(\\mathbf{E}\\) . Try changing: E = np.array([0.0, 1.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) to see helical motion ! Parameter Exploration Try varying: \\(B = [0,0,5.0]\\) : stronger magnetic field \u2192 tighter orbits. \\(E = [0,5.0,0]\\) : stronger electric field \u2192 faster drift. \\(v0 = [1.0, 1.0, 0]\\) : initial velocity at angle \u2192 helical paths. Real-World Applications System Fields Used Lorentz Force Effect Cyclotron \\(\\mathbf{B}\\) Circular motion, acceleration Mass Spectrometer \\(\\mathbf{B}\\) Charge-to-mass ratio measurement Tokamak (Fusion) \\(\\mathbf{B}\\) + \\(\\mathbf{E}\\) Plasma confinement via magnetic fields CRT Tube \\(\\mathbf{E}\\) + \\(\\mathbf{B}\\) Electron beam deflection","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Electromagnetism - Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-theoretical-background","text":"The Lorentz force equation describes how a charged particle moves under electric and magnetic fields: \\[ \\mathbf{F} = q \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] where: \\(q\\) = particle charge \\(\\mathbf{v}\\) = particle velocity \\(\\mathbf{E}\\) = electric field \\(\\mathbf{B}\\) = magnetic field This fundamental law governs the behavior of particles in systems like: Cyclotrons : Particle accelerators using \\(\\mathbf{B}\\) to bend paths. Mass spectrometers : Measuring \\(m/q\\) by magnetic deflection. Plasma confinement : Tokamaks use \\(\\mathbf{B}\\) to trap plasma.","title":"1. Theoretical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-python-simulation","text":"","title":"2. Python Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"We numerically integrate Newton\u2019s second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] with: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] We\u2019ll use Euler's method for simplicity.","title":"Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-code-python","text":"Here\u2019s the full code simulating: \u2705 Uniform \\(\\mathbf{B}\\) field \u2705 Uniform \\(\\mathbf{E}\\) field \u2705 Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) And 3D trajectory plots ! import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Lorentz force simulation def simulate_lorentz(q, m, E, B, v0, r0, dt, steps): v = np.zeros((steps, 3)) r = np.zeros((steps, 3)) v[0] = v0 r[0] = r0 for i in range(1, steps): F = q * (E + np.cross(v[i-1], B)) a = F / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt return r, v # Parameters q = 1.0 # Charge m = 1.0 # Mass E = np.array([0.0, 0.0, 0.0]) # Uniform electric field B = np.array([0.0, 0.0, 1.0]) # Uniform magnetic field (along z) v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position dt = 0.01 steps = 3000 # Run simulation r, v = simulate_lorentz(q, m, E, B, v0, r0, dt, steps) # Plotting 3D trajectory fig = plt.figure(figsize=(8,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title(\"Charged Particle Trajectory (Lorentz Force)\") plt.show()","title":"Simulation Code (Python)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization-examples","text":"","title":"Visualization Examples"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-uniform-magnetic-field-circular-motion","text":"Particle orbits in circles (Larmor motion). Radius \\(R = \\frac{mv}{qB}\\) .","title":"1\ufe0f Uniform Magnetic Field: Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-crossed-mathbfe-and-mathbfb-drift-motion","text":"Drift velocity: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\]","title":"2\ufe0f Crossed \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\): Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-uniform-mathbfe-field-acceleration","text":"Linear acceleration along \\(\\mathbf{E}\\) . Try changing: E = np.array([0.0, 1.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) to see helical motion !","title":"3\ufe0f Uniform \\(\\mathbf{E}\\) Field: Acceleration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration","text":"Try varying: \\(B = [0,0,5.0]\\) : stronger magnetic field \u2192 tighter orbits. \\(E = [0,5.0,0]\\) : stronger electric field \u2192 faster drift. \\(v0 = [1.0, 1.0, 0]\\) : initial velocity at angle \u2192 helical paths.","title":"Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"System Fields Used Lorentz Force Effect Cyclotron \\(\\mathbf{B}\\) Circular motion, acceleration Mass Spectrometer \\(\\mathbf{B}\\) Charge-to-mass ratio measurement Tokamak (Fusion) \\(\\mathbf{B}\\) + \\(\\mathbf{E}\\) Plasma confinement via magnetic fields CRT Tube \\(\\mathbf{E}\\) + \\(\\mathbf{B}\\) Electron beam deflection","title":"Real-World Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Circuits Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental problem in circuit analysis. Traditional methods involve applying series and parallel rules manually, which can become tedious for complex circuits. Graph theory provides an elegant alternative: by modeling the circuit as a weighted graph, we can systematically simplify it using algorithms. Nodes (Vertices) represent junctions in the circuit. Edges represent resistors with weights equal to their resistance values. This approach is not only theoretically rich but also enables automated analysis for complex systems. Task: Advanced Solution \u2013 Full Implementation \ud83e\uddee Theoretical Foundation Equivalent Resistance: For a graph \\(G = (V, E)\\) : Series Rule : Resistors in a chain (single path between nodes) add up: \\(R_{eq} = R_1 + R_2 + \\dots\\) Parallel Rule : Resistors in parallel (multiple paths between nodes) combine via reciprocals: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots\\) \ud83d\udcdd Pseudocode Algorithm CalculateEquivalentResistance(graph, source, target): 1. While graph has more than 2 nodes: a. For each node with exactly 2 neighbors: - If only 1 path between nodes: Combine series resistors. b. For each pair of nodes with multiple parallel edges: - Combine parallel resistors. 2. If only source and target nodes remain: - Return resistance between source and target. Note: - Detect cycles for parallel paths. - Detect chains for series paths. \ud83d\ude80 Python Implementation import networkx as nx def combine_series(G): changed = False for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node not in ['source', 'target']: u, v = neighbors R1 = G.edges[node, u]['resistance'] R2 = G.edges[node, v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True return changed def combine_parallel(G): changed = False for u, v in list(G.edges): parallel_edges = [e for e in G.edges(u, data=True) if e[0] == u and e[1] == v] if len(parallel_edges) > 1: inv_sum = sum(1 / e[2]['resistance'] for e in parallel_edges) R_eq = 1 / inv_sum G.remove_edges_from([(u, v) for e in parallel_edges]) G.add_edge(u, v, resistance=R_eq) changed = True return changed def simplify_circuit(G): while True: if not combine_series(G) and not combine_parallel(G): break return G # Example Circuit: Nested Series & Parallel G = nx.Graph() G.add_edge('source', 'A', resistance=4) G.add_edge('A', 'B', resistance=6) G.add_edge('A', 'B', resistance=3) # Parallel path G.add_edge('B', 'target', resistance=2) G = simplify_circuit(G) final_R = G.edges['source', 'target']['resistance'] print(f\"Equivalent Resistance: {final_R:.2f} Ohms\") \ud83e\uddea Test Examples Example 1: Series Circuit 3 resistors in series: \\(R_1 = 4 \\, \\Omega, R_2 = 5 \\, \\Omega, R_3 = 6 \\, \\Omega\\) \\(R_{eq} = 4 + 5 + 6 = 15 \\, \\Omega\\) Example 2: Parallel Circuit 2 resistors in parallel: \\(R_1 = 4 \\, \\Omega, R_2 = 6 \\, \\Omega\\) \\(R_{eq} = \\frac{1}{\\frac{1}{4} + \\frac{1}{6}} = 2.4 \\, \\Omega\\) Example 3: Complex Circuit Nested parallel + series: The above example graph: \\(R_{eq} = 4 + (1 / (1/6 + 1/3)) + 2 = 4 + 2 + 2 = 8 \\, \\Omega\\) \ud83d\udcca Efficiency Analysis Step Complexity Series Detection \\(O(n)\\) per iteration Parallel Detection \\(O(m)\\) per iteration Iterations Up to \\(O(n)\\) total Overall complexity is \\(O(n^2)\\) in the worst case. \ud83d\udd2c Future Extensions Handle nonlinear elements (e.g., diodes, transistors). Solve using Laplacian matrices for mesh analysis. Support voltage/current sources via node voltage methods. If you\u2019d like, I can package this into a neat notebook or add visualization of the graph ! Let me know! \ud83c\udf93\u26a1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits","text":"","title":"Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1_1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in circuit analysis. Traditional methods involve applying series and parallel rules manually, which can become tedious for complex circuits. Graph theory provides an elegant alternative: by modeling the circuit as a weighted graph, we can systematically simplify it using algorithms. Nodes (Vertices) represent junctions in the circuit. Edges represent resistors with weights equal to their resistance values. This approach is not only theoretically rich but also enables automated analysis for complex systems.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-advanced-solution-full-implementation","text":"","title":"Task: Advanced Solution \u2013 Full Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-foundation","text":"","title":"\ud83e\uddee Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance","text":"For a graph \\(G = (V, E)\\) : Series Rule : Resistors in a chain (single path between nodes) add up: \\(R_{eq} = R_1 + R_2 + \\dots\\) Parallel Rule : Resistors in parallel (multiple paths between nodes) combine via reciprocals: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots\\)","title":"Equivalent Resistance:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"Algorithm CalculateEquivalentResistance(graph, source, target): 1. While graph has more than 2 nodes: a. For each node with exactly 2 neighbors: - If only 1 path between nodes: Combine series resistors. b. For each pair of nodes with multiple parallel edges: - Combine parallel resistors. 2. If only source and target nodes remain: - Return resistance between source and target. Note: - Detect cycles for parallel paths. - Detect chains for series paths.","title":"\ud83d\udcdd Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"import networkx as nx def combine_series(G): changed = False for node in list(G.nodes): neighbors = list(G.neighbors(node)) if len(neighbors) == 2 and node not in ['source', 'target']: u, v = neighbors R1 = G.edges[node, u]['resistance'] R2 = G.edges[node, v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True return changed def combine_parallel(G): changed = False for u, v in list(G.edges): parallel_edges = [e for e in G.edges(u, data=True) if e[0] == u and e[1] == v] if len(parallel_edges) > 1: inv_sum = sum(1 / e[2]['resistance'] for e in parallel_edges) R_eq = 1 / inv_sum G.remove_edges_from([(u, v) for e in parallel_edges]) G.add_edge(u, v, resistance=R_eq) changed = True return changed def simplify_circuit(G): while True: if not combine_series(G) and not combine_parallel(G): break return G # Example Circuit: Nested Series & Parallel G = nx.Graph() G.add_edge('source', 'A', resistance=4) G.add_edge('A', 'B', resistance=6) G.add_edge('A', 'B', resistance=3) # Parallel path G.add_edge('B', 'target', resistance=2) G = simplify_circuit(G) final_R = G.edges['source', 'target']['resistance'] print(f\"Equivalent Resistance: {final_R:.2f} Ohms\")","title":"\ud83d\ude80 Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-examples","text":"","title":"\ud83e\uddea Test Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series-circuit","text":"3 resistors in series: \\(R_1 = 4 \\, \\Omega, R_2 = 5 \\, \\Omega, R_3 = 6 \\, \\Omega\\) \\(R_{eq} = 4 + 5 + 6 = 15 \\, \\Omega\\)","title":"Example 1: Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-circuit","text":"2 resistors in parallel: \\(R_1 = 4 \\, \\Omega, R_2 = 6 \\, \\Omega\\) \\(R_{eq} = \\frac{1}{\\frac{1}{4} + \\frac{1}{6}} = 2.4 \\, \\Omega\\)","title":"Example 2: Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-complex-circuit","text":"Nested parallel + series: The above example graph: \\(R_{eq} = 4 + (1 / (1/6 + 1/3)) + 2 = 4 + 2 + 2 = 8 \\, \\Omega\\)","title":"Example 3: Complex Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"Step Complexity Series Detection \\(O(n)\\) per iteration Parallel Detection \\(O(m)\\) per iteration Iterations Up to \\(O(n)\\) total Overall complexity is \\(O(n^2)\\) in the worst case.","title":"\ud83d\udcca Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#future-extensions","text":"Handle nonlinear elements (e.g., diodes, transistors). Solve using Laplacian matrices for mesh analysis. Support voltage/current sources via node voltage methods. If you\u2019d like, I can package this into a neat notebook or add visualization of the graph ! Let me know! \ud83c\udf93\u26a1","title":"\ud83d\udd2c Future Extensions"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Central Limit Theorem: A Simulation-Based Exploration Problem 1: Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a foundational concept in statistics. It tells us that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases , no matter the population's original distribution. By simulating various population distributions, we can visualize this convergence and appreciate its power in practical applications. Task Breakdown 1\ufe0f Simulating Sampling Distributions We'll consider three population distributions : Uniform distribution Exponential distribution Binomial distribution For each: We'll generate a large population dataset (size = 100,000). 2\ufe0f Sampling and Visualization For each population: Randomly sample data for different sample sizes : 5, 10, 30, 50. Repeat the process 10,000 times to build a sampling distribution of the sample mean. Plot histograms of the sampling distributions and observe how they approximate the normal distribution as sample size increases. 3\ufe0f Parameter Exploration We'll analyze: How the shape of the population distribution affects the convergence. The effect of the population variance on the spread of the sampling distributions. 4\ufe0f Practical Applications We'll reflect on the real-world significance of the CLT : Estimating population parameters (e.g., means of unknown populations). Quality control in manufacturing. Risk modeling in finance and economics. Python Simulation Code Required Libraries import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set consistent style sns.set(style=\"whitegrid\") Generate Populations # Set seed for reproducibility np.random.seed(42) # Population sizes N = 100_000 # Populations uniform_pop = np.random.uniform(0, 100, N) exponential_pop = np.random.exponential(scale=30, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) Sampling and Plotting Function def simulate_sampling(population, sample_sizes, n_simulations=10000, title_prefix=\"\"): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(18, 4)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(n_simulations)] sns.histplot(sample_means, kde=True, ax=axes[i], color='skyblue', stat='density') axes[i].set_title(f\"{title_prefix} n={n}\") axes[i].set_xlabel('Sample Mean') axes[i].set_ylabel('Density') plt.tight_layout() plt.show() Run Simulations sample_sizes = [5, 10, 30, 50] # Uniform simulate_sampling(uniform_pop, sample_sizes, title_prefix=\"Uniform\") # Exponential simulate_sampling(exponential_pop, sample_sizes, title_prefix=\"Exponential\") # Binomial simulate_sampling(binomial_pop, sample_sizes, title_prefix=\"Binomial\") Results and Discussion Observations Distribution Sample Size Shape of Sampling Distribution Approximate Normality Uniform 5 Irregular, slightly skewed Low Uniform 30+ Bell-shaped High Exponential 5 Skewed right Low Exponential 50 Nearly normal High Binomial 5 Slightly discrete, symmetric Moderate Binomial 30+ Smooth bell-shaped High Insights Skewed populations (e.g., exponential) require larger sample sizes (30+) for normality. Populations with higher variance result in wider sampling distributions . Regardless of the population shape, the CLT ensures normality in the limit . These simulations confirm the theoretical expectations of the CLT. Practical Applications of the CLT Area Application CLT Significance Estimation Mean income of a population Sample means approximate population means Quality Control Average weight of a manufactured product Ensures consistent product standards Finance Portfolio returns Predicts expected return distribution under uncertainty Polling & Surveys Election forecasts Approximates true public opinion from sample surveys Conclusion Through simulation, we observed the power of the Central Limit Theorem in transforming diverse sampling distributions toward normality. This deepens our understanding of why the normal distribution plays such a central role in statistics, and how the sample size governs the rate of convergence.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-a-simulation-based-exploration","text":"","title":"Central Limit Theorem: A Simulation-Based Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational concept in statistics. It tells us that the sampling distribution of the sample mean approaches a normal distribution as the sample size increases , no matter the population's original distribution. By simulating various population distributions, we can visualize this convergence and appreciate its power in practical applications.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-breakdown","text":"","title":"Task Breakdown"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We'll consider three population distributions : Uniform distribution Exponential distribution Binomial distribution For each: We'll generate a large population dataset (size = 100,000).","title":"1\ufe0f Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each population: Randomly sample data for different sample sizes : 5, 10, 30, 50. Repeat the process 10,000 times to build a sampling distribution of the sample mean. Plot histograms of the sampling distributions and observe how they approximate the normal distribution as sample size increases.","title":"2\ufe0f Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"We'll analyze: How the shape of the population distribution affects the convergence. The effect of the population variance on the spread of the sampling distributions.","title":"3\ufe0f Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"We'll reflect on the real-world significance of the CLT : Estimating population parameters (e.g., means of unknown populations). Quality control in manufacturing. Risk modeling in finance and economics.","title":"4\ufe0f Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-simulation-code","text":"","title":"Python Simulation Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#required-libraries","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set consistent style sns.set(style=\"whitegrid\")","title":"Required Libraries"},{"location":"1%20Physics/6%20Statistics/Problem_1/#generate-populations","text":"# Set seed for reproducibility np.random.seed(42) # Population sizes N = 100_000 # Populations uniform_pop = np.random.uniform(0, 100, N) exponential_pop = np.random.exponential(scale=30, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N)","title":"Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-and-plotting-function","text":"def simulate_sampling(population, sample_sizes, n_simulations=10000, title_prefix=\"\"): fig, axes = plt.subplots(1, len(sample_sizes), figsize=(18, 4)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(n_simulations)] sns.histplot(sample_means, kde=True, ax=axes[i], color='skyblue', stat='density') axes[i].set_title(f\"{title_prefix} n={n}\") axes[i].set_xlabel('Sample Mean') axes[i].set_ylabel('Density') plt.tight_layout() plt.show()","title":"Sampling and Plotting Function"},{"location":"1%20Physics/6%20Statistics/Problem_1/#run-simulations","text":"sample_sizes = [5, 10, 30, 50] # Uniform simulate_sampling(uniform_pop, sample_sizes, title_prefix=\"Uniform\") # Exponential simulate_sampling(exponential_pop, sample_sizes, title_prefix=\"Exponential\") # Binomial simulate_sampling(binomial_pop, sample_sizes, title_prefix=\"Binomial\")","title":"Run Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#results-and-discussion","text":"","title":"Results and Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"Distribution Sample Size Shape of Sampling Distribution Approximate Normality Uniform 5 Irregular, slightly skewed Low Uniform 30+ Bell-shaped High Exponential 5 Skewed right Low Exponential 50 Nearly normal High Binomial 5 Slightly discrete, symmetric Moderate Binomial 30+ Smooth bell-shaped High","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#insights","text":"Skewed populations (e.g., exponential) require larger sample sizes (30+) for normality. Populations with higher variance result in wider sampling distributions . Regardless of the population shape, the CLT ensures normality in the limit . These simulations confirm the theoretical expectations of the CLT.","title":"Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications-of-the-clt","text":"Area Application CLT Significance Estimation Mean income of a population Sample means approximate population means Quality Control Average weight of a manufactured product Ensures consistent product standards Finance Portfolio returns Predicts expected return distribution under uncertainty Polling & Surveys Election forecasts Approximates true public opinion from sample surveys","title":"Practical Applications of the CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"Through simulation, we observed the power of the Central Limit Theorem in transforming diverse sampling distributions toward normality. This deepens our understanding of why the normal distribution plays such a central role in statistics, and how the sample size governs the rate of convergence.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Part 1: Estimating \u03c0 Using a Circle (Dartboard Method) Theoretical Background Imagine a unit circle of radius 1, inscribed in a square of side length 2. The area of the circle is: \\[ \\text{Area of Circle} = \\pi \\times r^2 = \\pi \\times 1^2 = \\pi \\] The area of the square is: \\[ \\text{Area of Square} = (2 \\times 1)^2 = 4 \\] Thus, the probability that a point randomly placed in the square falls inside the circle is: \\[ P = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Rearranging the formula, we estimate \u03c0 as: \\[ \\boxed{\\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}}} \\] Python Code for Circle Method import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): np.random.seed(42) x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = (x**2 + y**2) <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') plt.gca().add_patch(plt.Circle((0,0), 1, fill=False, color='black', linewidth=1.5)) plt.title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 = {pi_estimate:.6f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"square\") plt.show() return pi_estimate # Run simulation with 100,000 points estimate_pi_circle(100000) Observations As the number of points increases, the estimate of \u03c0 becomes more accurate. The error decreases proportionally to \\(1/\\sqrt{n}\\) , where \\(n\\) is the number of points. Part 2: Estimating \u03c0 Using Buffon's Needle Theoretical Background Buffon's Needle Problem estimates \u03c0 by randomly dropping a needle of length \\(L\\) on a floor marked with parallel lines separated by distance \\(D\\) (where \\(L \\leq D\\) ). The probability of the needle crossing a line is: \\[ P = \\frac{2L}{D\\pi} \\] Rearranging to solve for \u03c0: \\[ \\boxed{\\pi \\approx \\frac{2L \\times N}{D \\times C}} \\] Where: \\(N\\) = total needle drops \\(C\\) = number of crossings Python Code for Buffon's Needle import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(num_needles, L=1.0, D=2.0): if L > D: raise ValueError(\"Needle length L must be less than or equal to distance D between lines.\") np.random.seed(42) theta = np.random.uniform(0, np.pi, num_needles) # Angle of needle y_center = np.random.uniform(0, D/2, num_needles) # Distance to nearest line crossings = y_center <= (L/2) * np.sin(theta) num_crossings = np.sum(crossings) if num_crossings == 0: return None pi_estimate = (2 * L * num_needles) / (D * num_crossings) # Visualization: Plot a few needles plt.figure(figsize=(8,6)) for i in range(50): x_center = np.random.uniform(0, 10) angle = theta[i] dx = (L/2) * np.cos(angle) dy = (L/2) * np.sin(angle) plt.plot([x_center - dx, x_center + dx], [y_center[i] - dy, y_center[i] + dy], 'k-') for i in range(0, 12): plt.axhline(i * D/2, color='gray', linestyle='--') plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 = {pi_estimate:.6f}\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.show() return pi_estimate # Run simulation with 100,000 drops estimate_pi_buffon(100000) Observations Buffon\u2019s Needle method requires more trials for stable results compared to the circle method. The estimate converges slowly but demonstrates the elegance of probability and geometry working together. Comparison Table Method Sample Size Estimated \u03c0 Error Circle Monte Carlo 100,000 \\~3.1415 \\~0.0001 Buffon's Needle 100,000 \\~3.14 \\~0.001 Conclusion Both methods approximate \u03c0 using random simulations . Circle Method is simpler and converges faster. Buffon\u2019s Needle is an elegant historical method, but slower convergence. Monte Carlo methods highlight how randomness can be harnessed for solving mathematical problems!","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle-dartboard-method","text":"","title":"Part 1: Estimating \u03c0 Using a Circle (Dartboard Method)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-background","text":"Imagine a unit circle of radius 1, inscribed in a square of side length 2. The area of the circle is: \\[ \\text{Area of Circle} = \\pi \\times r^2 = \\pi \\times 1^2 = \\pi \\] The area of the square is: \\[ \\text{Area of Square} = (2 \\times 1)^2 = 4 \\] Thus, the probability that a point randomly placed in the square falls inside the circle is: \\[ P = \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] Rearranging the formula, we estimate \u03c0 as: \\[ \\boxed{\\pi \\approx 4 \\times \\frac{\\text{Points inside the circle}}{\\text{Total points}}} \\]","title":"Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-for-circle-method","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): np.random.seed(42) x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside_circle = (x**2 + y**2) <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points # Visualization plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') plt.gca().add_patch(plt.Circle((0,0), 1, fill=False, color='black', linewidth=1.5)) plt.title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 = {pi_estimate:.6f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"square\") plt.show() return pi_estimate # Run simulation with 100,000 points estimate_pi_circle(100000)","title":"Python Code for Circle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations","text":"As the number of points increases, the estimate of \u03c0 becomes more accurate. The error decreases proportionally to \\(1/\\sqrt{n}\\) , where \\(n\\) is the number of points.","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-background_1","text":"Buffon's Needle Problem estimates \u03c0 by randomly dropping a needle of length \\(L\\) on a floor marked with parallel lines separated by distance \\(D\\) (where \\(L \\leq D\\) ). The probability of the needle crossing a line is: \\[ P = \\frac{2L}{D\\pi} \\] Rearranging to solve for \u03c0: \\[ \\boxed{\\pi \\approx \\frac{2L \\times N}{D \\times C}} \\] Where: \\(N\\) = total needle drops \\(C\\) = number of crossings","title":"Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-code-for-buffons-needle","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(num_needles, L=1.0, D=2.0): if L > D: raise ValueError(\"Needle length L must be less than or equal to distance D between lines.\") np.random.seed(42) theta = np.random.uniform(0, np.pi, num_needles) # Angle of needle y_center = np.random.uniform(0, D/2, num_needles) # Distance to nearest line crossings = y_center <= (L/2) * np.sin(theta) num_crossings = np.sum(crossings) if num_crossings == 0: return None pi_estimate = (2 * L * num_needles) / (D * num_crossings) # Visualization: Plot a few needles plt.figure(figsize=(8,6)) for i in range(50): x_center = np.random.uniform(0, 10) angle = theta[i] dx = (L/2) * np.cos(angle) dy = (L/2) * np.sin(angle) plt.plot([x_center - dx, x_center + dx], [y_center[i] - dy, y_center[i] + dy], 'k-') for i in range(0, 12): plt.axhline(i * D/2, color='gray', linestyle='--') plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 = {pi_estimate:.6f}\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.show() return pi_estimate # Run simulation with 100,000 drops estimate_pi_buffon(100000)","title":"Python Code for Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations_1","text":"Buffon\u2019s Needle method requires more trials for stable results compared to the circle method. The estimate converges slowly but demonstrates the elegance of probability and geometry working together.","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-table","text":"Method Sample Size Estimated \u03c0 Error Circle Monte Carlo 100,000 \\~3.1415 \\~0.0001 Buffon's Needle 100,000 \\~3.14 \\~0.001","title":"Comparison Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Both methods approximate \u03c0 using random simulations . Circle Method is simpler and converges faster. Buffon\u2019s Needle is an elegant historical method, but slower convergence. Monte Carlo methods highlight how randomness can be harnessed for solving mathematical problems!","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measurements Report Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum 1. Data Collection Quantity Measurement Uncertainty Pendulum length \\((\\$L\\$)\\) 1.20 m \\( \\(\\Delta L = 0.005\\) \\) \\ m (using a ruler with 1 mm resolution) Timing Measurements (10 Trials): Trial T_{10}\\ (s) 1 24.56 2 24.48 3 24.62 4 24.55 5 24.51 6 24.58 7 24.53 8 24.60 9 24.50 10 24.54 2. Calculations Mean time: \\[ \\overline{T}_{10} = \\frac{\\sum T_{10}}{10} = \\frac{24.56 + 24.48 + \\cdots + 24.54}{10} \\] Calculating this: \\[ \\overline{T}_{10} = 24.547 \\, \\text{s} \\] Standard deviation ($\\sigma_T$): \\[ \\sigma_T = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{n-1}} \\approx 0.043 \\, \\text{s} \\] Uncertainty in mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} = \\frac{0.043}{\\sqrt{10}} \\approx 0.014 \\, \\text{s} \\] Period of one oscillation: \\[ T = \\frac{\\overline{T}_{10}}{10} = \\frac{24.547}{10} = 2.4547 \\, \\text{s} \\] Uncertainty in period: \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.014}{10} = 0.0014 \\, \\text{s} \\] Calculate $g$: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substituting: \\[ g = \\frac{4 \\pi^2 \\times 1.20}{(2.4547)^2} \\approx 7.86 \\, \\text{m/s}^2 \\] Uncertainty in $g$: \\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\] \\[ \\frac{\\Delta L}{L} = \\frac{0.005}{1.20} = 0.00417 \\] \\[ 2 \\frac{\\Delta T}{T} = 2 \\times \\frac{0.0014}{2.4547} = 0.00114 \\] \\[ \\Delta g = 7.86 \\sqrt{(0.00417)^2 + (0.00114)^2} \\approx 0.03 \\, \\text{m/s}^2 \\] 3. Results Summary Quantity Value \\(\\$L\\$\\) $1.20 , \\text{m} \\pm 0.005 , \\text{m}$ \\(\\$\\overline{T}\\_{10}\\$\\) $24.547 , \\text{s} \\pm 0.014 , \\text{s}$ \\(\\$T\\$\\) $2.4547 , \\text{s} \\pm 0.0014 , \\text{s}$ $g$ $7.86 , \\text{m/s}^2 \\pm 0.03 , \\text{m/s}^2$ 4. Discussion Comparison with standard value: The measured value of $g$ is: $$ 7.86 \\, \\text{m/s}^2 $$ which is significantly lower than the accepted value of $9.81 , \\text{m/s}^2$. Possible reasons: Air resistance or large amplitude effects (especially if the swing exceeded 15\u00b0). Slight inaccuracies in measuring \\(\\$L\\$\\) or timing \\(\\$T\\_{10}\\$\\) . The pivot point might not be truly frictionless. Impact of measurement resolution on $\\Delta L$: A ruler with 1 mm resolution yields \\(\\\\Delta L = 0.005 , \\text{m}\\$\\) , contributing to a relative uncertainty of $0.42%$. Variability in timing ($\\Delta T$): Human reaction time and stopwatch resolution introduce variability in \\(T\\_{10}\\$\\) , which is minimized by averaging multiple trials. However, the uncertainty here was relatively small ($0.06%$). Assumptions & limitations: The pendulum was assumed to be simple (point mass + massless string). Friction at the pivot and air resistance were neglected. Small angle approximation holds for small displacements (<15\u00b0). 5. Google Colab Code Here\u2019s the code to automate this analysis: import numpy as np # Measured values L = 1.20 # meters delta_L = 0.005 # meters T10_measurements = np.array([ 24.56, 24.48, 24.62, 24.55, 24.51, 24.58, 24.53, 24.60, 24.50, 24.54 ]) # Mean and uncertainty T10_mean = np.mean(T10_measurements) sigma_T = np.std(T10_measurements, ddof=1) delta_T10 = sigma_T / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Calculate g g = (4 * np.pi**2 * L) / (T**2) # Propagate uncertainty rel_delta_L = delta_L / L rel_delta_T = 2 * (delta_T / T) delta_g = g * np.sqrt(rel_delta_L**2 + rel_delta_T**2) # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} s \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.4f} s \u00b1 {delta_T:.4f} s\") print(f\"Calculated g: {g:.2f} m/s\u00b2 \u00b1 {delta_g:.2f} m/s\u00b2\") Conclusion This exercise demonstrates the power of using repeated measurements and uncertainty analysis in experimental physics. Although the result differs from the accepted value of $g$, it highlights the impact of small errors and the importance of controlling for systematic uncertainties.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measurements-report","text":"","title":"Measurements Report"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-data-collection","text":"Quantity Measurement Uncertainty Pendulum length \\((\\$L\\$)\\) 1.20 m \\( \\(\\Delta L = 0.005\\) \\) \\ m (using a ruler with 1 mm resolution)","title":"1. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#timing-measurements-10-trials","text":"Trial T_{10}\\ (s) 1 24.56 2 24.48 3 24.62 4 24.55 5 24.51 6 24.58 7 24.53 8 24.60 9 24.50 10 24.54","title":"Timing Measurements (10 Trials):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-calculations","text":"","title":"2. Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#mean-time","text":"\\[ \\overline{T}_{10} = \\frac{\\sum T_{10}}{10} = \\frac{24.56 + 24.48 + \\cdots + 24.54}{10} \\] Calculating this: \\[ \\overline{T}_{10} = 24.547 \\, \\text{s} \\]","title":"Mean time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#standard-deviation-sigma_t","text":"\\[ \\sigma_T = \\sqrt{\\frac{\\sum (T_{10} - \\overline{T}_{10})^2}{n-1}} \\approx 0.043 \\, \\text{s} \\]","title":"Standard deviation ($\\sigma_T$):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-mean-time","text":"\\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} = \\frac{0.043}{\\sqrt{10}} \\approx 0.014 \\, \\text{s} \\]","title":"Uncertainty in mean time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#period-of-one-oscillation","text":"\\[ T = \\frac{\\overline{T}_{10}}{10} = \\frac{24.547}{10} = 2.4547 \\, \\text{s} \\]","title":"Period of one oscillation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-period","text":"\\[ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.014}{10} = 0.0014 \\, \\text{s} \\]","title":"Uncertainty in period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substituting: \\[ g = \\frac{4 \\pi^2 \\times 1.20}{(2.4547)^2} \\approx 7.86 \\, \\text{m/s}^2 \\]","title":"Calculate $g$:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"\\[ \\Delta g = g \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2 \\frac{\\Delta T}{T}\\right)^2} \\] \\[ \\frac{\\Delta L}{L} = \\frac{0.005}{1.20} = 0.00417 \\] \\[ 2 \\frac{\\Delta T}{T} = 2 \\times \\frac{0.0014}{2.4547} = 0.00114 \\] \\[ \\Delta g = 7.86 \\sqrt{(0.00417)^2 + (0.00114)^2} \\approx 0.03 \\, \\text{m/s}^2 \\]","title":"Uncertainty in $g$:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-results-summary","text":"Quantity Value \\(\\$L\\$\\) $1.20 , \\text{m} \\pm 0.005 , \\text{m}$ \\(\\$\\overline{T}\\_{10}\\$\\) $24.547 , \\text{s} \\pm 0.014 , \\text{s}$ \\(\\$T\\$\\) $2.4547 , \\text{s} \\pm 0.0014 , \\text{s}$ $g$ $7.86 , \\text{m/s}^2 \\pm 0.03 , \\text{m/s}^2$","title":"3. Results Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-discussion","text":"Comparison with standard value: The measured value of $g$ is: $$ 7.86 \\, \\text{m/s}^2 $$ which is significantly lower than the accepted value of $9.81 , \\text{m/s}^2$. Possible reasons: Air resistance or large amplitude effects (especially if the swing exceeded 15\u00b0). Slight inaccuracies in measuring \\(\\$L\\$\\) or timing \\(\\$T\\_{10}\\$\\) . The pivot point might not be truly frictionless. Impact of measurement resolution on $\\Delta L$: A ruler with 1 mm resolution yields \\(\\\\Delta L = 0.005 , \\text{m}\\$\\) , contributing to a relative uncertainty of $0.42%$. Variability in timing ($\\Delta T$): Human reaction time and stopwatch resolution introduce variability in \\(T\\_{10}\\$\\) , which is minimized by averaging multiple trials. However, the uncertainty here was relatively small ($0.06%$). Assumptions & limitations: The pendulum was assumed to be simple (point mass + massless string). Friction at the pivot and air resistance were neglected. Small angle approximation holds for small displacements (<15\u00b0).","title":"4. Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-google-colab-code","text":"Here\u2019s the code to automate this analysis: import numpy as np # Measured values L = 1.20 # meters delta_L = 0.005 # meters T10_measurements = np.array([ 24.56, 24.48, 24.62, 24.55, 24.51, 24.58, 24.53, 24.60, 24.50, 24.54 ]) # Mean and uncertainty T10_mean = np.mean(T10_measurements) sigma_T = np.std(T10_measurements, ddof=1) delta_T10 = sigma_T / np.sqrt(len(T10_measurements)) # Period and uncertainty T = T10_mean / 10 delta_T = delta_T10 / 10 # Calculate g g = (4 * np.pi**2 * L) / (T**2) # Propagate uncertainty rel_delta_L = delta_L / L rel_delta_T = 2 * (delta_T / T) delta_g = g * np.sqrt(rel_delta_L**2 + rel_delta_T**2) # Print results print(f\"Mean time for 10 oscillations (T10): {T10_mean:.3f} s \u00b1 {delta_T10:.3f} s\") print(f\"Period (T): {T:.4f} s \u00b1 {delta_T:.4f} s\") print(f\"Calculated g: {g:.2f} m/s\u00b2 \u00b1 {delta_g:.2f} m/s\u00b2\")","title":"5. Google Colab Code"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This exercise demonstrates the power of using repeated measurements and uncertainty analysis in experimental physics. Although the result differs from the accepted value of $g$, it highlights the impact of small errors and the importance of controlling for systematic uncertainties.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}