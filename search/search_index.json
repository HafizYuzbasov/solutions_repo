{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, though elementary in its structure, provides a substantial basis for studying foundational physical laws. The investigation of how a projectile's range depends on the angle of projection brings together both theoretical and practical insights. This exploration involves not only basic trigonometry and calculus but also reflects a wide variety of real-world applications ranging from sports to aerospace dynamics. 1. Theoretical Foundation Projectile motion can be described by Newton's second law and the kinematic equations. Assuming no air resistance, the only force acting on the object (after it's projected) is gravity. Governing Equations The equations of motion in the x and y directions can be derived from: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow x(t) = v_0 \\cos(\\theta) t \\] \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Launch angle - \\( g \\) : Acceleration due to gravity (9.81 m/s\u00b2) - \\( t \\) : Time Time of Flight The time at which the projectile returns to the same vertical level is: $$ T = \\frac{2v_0\\sin(\\theta)}{g} $$ Range The horizontal range ( \\(R\\) ) of the projectile is given by: $$ R = \\frac{v_0^2\\sin(2\\theta)}{g} $$ This shows the range is maximum when $$ \\theta = 45^\\circ $$. 2. Analysis of the Range The horizontal range varies as a function of the angle of projection: At \\( \\(\\theta = 0^\\circ\\) \\) or \\( \\(\\theta = 90^\\circ\\) \\) , range is zero. Maximum range occurs at \\( \\(45^\\circ\\) \\) Range is symmetric about \\( \\(45^\\circ\\) \\) Influence of Parameters: Initial velocity : Quadratically proportional to range. Gravity : Inversely proportional to range. Angle : Influences both the vertical and horizontal motion. 3. Practical Applications Sports : Understanding how to optimize angle and force for maximum throw or jump. Ballistics : Predicting the path of projectiles with drag. Engineering : Simulations of component launches or material drops. Astrophysics : Modeling the launch paths of satellites with corrections. 4. Implementation in Python Below is Python code to simulate projectile motion with different angles and velocities. A. Plot for 50 m/s and Angles 15, 45, 75 Degrees import numpy as np import matplotlib.pyplot as plt def projectile(v0, theta_deg): g = 9.81 theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y angles = [15, 45, 75] plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(50, angle) plt.plot(x, y, label=f'{angle}\\u00b0') plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show() B. Plot for Velocities 30, 40, 50 m/s at 45 Degrees velocities = [30, 40, 50] plt.figure(figsize=(10,6)) for v in velocities: x, y = projectile(v, 45) plt.plot(x, y, label=f'{v} m/s') plt.title('Projectile Motion for Different Velocities (45 Degrees)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show() Range Visualization and Effects These plots visually confirm: - Greater velocity leads to higher and farther motion. - Angle significantly affects maximum height and range. Limitations and Extensions This model does not account for: - Air resistance : Causes asymmetry and shorter range. - Wind : Alters trajectory path. - Launch height : If not from ground level, modifies equations. Extensions can include solving differential equations with drag force: $$ \\vec{F} = -kv\\vec{v} \\quad \\text{(linear drag)} $$","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, though elementary in its structure, provides a substantial basis for studying foundational physical laws. The investigation of how a projectile's range depends on the angle of projection brings together both theoretical and practical insights. This exploration involves not only basic trigonometry and calculus but also reflects a wide variety of real-world applications ranging from sports to aerospace dynamics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion can be described by Newton's second law and the kinematic equations. Assuming no air resistance, the only force acting on the object (after it's projected) is gravity.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations","text":"The equations of motion in the x and y directions can be derived from: \\[ \\frac{d^2x}{dt^2} = 0 \\Rightarrow x(t) = v_0 \\cos(\\theta) t \\] \\[ \\frac{d^2y}{dt^2} = -g \\Rightarrow y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Launch angle - \\( g \\) : Acceleration due to gravity (9.81 m/s\u00b2) - \\( t \\) : Time","title":"Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The time at which the projectile returns to the same vertical level is: $$ T = \\frac{2v_0\\sin(\\theta)}{g} $$","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range","text":"The horizontal range ( \\(R\\) ) of the projectile is given by: $$ R = \\frac{v_0^2\\sin(2\\theta)}{g} $$ This shows the range is maximum when $$ \\theta = 45^\\circ $$.","title":"Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range varies as a function of the angle of projection: At \\( \\(\\theta = 0^\\circ\\) \\) or \\( \\(\\theta = 90^\\circ\\) \\) , range is zero. Maximum range occurs at \\( \\(45^\\circ\\) \\) Range is symmetric about \\( \\(45^\\circ\\) \\)","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial velocity : Quadratically proportional to range. Gravity : Inversely proportional to range. Angle : Influences both the vertical and horizontal motion.","title":"Influence of Parameters:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Understanding how to optimize angle and force for maximum throw or jump. Ballistics : Predicting the path of projectiles with drag. Engineering : Simulations of component launches or material drops. Astrophysics : Modeling the launch paths of satellites with corrections.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"Below is Python code to simulate projectile motion with different angles and velocities.","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#a-plot-for-50-ms-and-angles-15-45-75-degrees","text":"import numpy as np import matplotlib.pyplot as plt def projectile(v0, theta_deg): g = 9.81 theta = np.radians(theta_deg) t_flight = 2 * v0 * np.sin(theta) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta) * t y = v0 * np.sin(theta) * t - 0.5 * g * t**2 return x, y angles = [15, 45, 75] plt.figure(figsize=(10,6)) for angle in angles: x, y = projectile(50, angle) plt.plot(x, y, label=f'{angle}\\u00b0') plt.title('Projectile Motion for Different Angles (v0 = 50 m/s)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show()","title":"A. Plot for 50 m/s and Angles 15, 45, 75 Degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#b-plot-for-velocities-30-40-50-ms-at-45-degrees","text":"velocities = [30, 40, 50] plt.figure(figsize=(10,6)) for v in velocities: x, y = projectile(v, 45) plt.plot(x, y, label=f'{v} m/s') plt.title('Projectile Motion for Different Velocities (45 Degrees)') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Distance (m)') plt.legend() plt.grid() plt.show()","title":"B. Plot for Velocities 30, 40, 50 m/s at 45 Degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-visualization-and-effects","text":"These plots visually confirm: - Greater velocity leads to higher and farther motion. - Angle significantly affects maximum height and range.","title":"Range Visualization and Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"This model does not account for: - Air resistance : Causes asymmetry and shorter range. - Wind : Alters trajectory path. - Launch height : If not from ground level, modifies equations. Extensions can include solving differential equations with drag force: $$ \\vec{F} = -kv\\vec{v} \\quad \\text{(linear drag)} $$","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating dynamical system that demonstrates a wide range of behaviors from simple harmonic motion to complex chaos. This transition occurs due to the interplay between natural oscillatory forces, damping mechanisms, and external periodic forces. This system provides a classical example for studying phenomena like resonance, energy dissipation, and chaotic dynamics, which are prevalent in many real-world systems such as suspension bridges, climate oscillations, and electronic circuits. 1. Theoretical Foundation We begin with the second-order nonlinear differential equation governing a forced damped pendulum: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement - \\(b\\) is the damping coefficient - \\(g\\) is the gravitational acceleration - \\(L\\) is the length of the pendulum - \\(A\\) is the amplitude of the external forcing - \\(\\omega\\) is the driving frequency Small-Angle Approximation For small oscillations, \\(\\sin(\\theta) \\approx \\theta\\) , and the equation simplifies to: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear differential equation that resembles the driven damped harmonic oscillator. 2. Analysis of Dynamics Pure Pendulum (No damping or forcing) \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = 0 \\] Damped Pendulum (With damping, no forcing) \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = 0 \\] Driven Undamped Pendulum (With forcing, no damping) \\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Forced Damped Pendulum (Full model) \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] 3. Practical Applications Mechanical Engineering : Suspension systems, rotating machinery Electrical Engineering : Analogies to driven RLC circuits Biomechanics : Modeling of human gait or limb movements under periodic stimulus Climate Science : Oscillatory climate models (e.g., El Nino cycles) 4. Implementation We use Python to simulate the system dynamics using the Runge-Kutta method. We visualize the angle vs. time, phase portraits, and explore chaotic behavior and resonance. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of external force omega = 2/3 # frequency of external force def pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.2, 0.0] # initial angle and angular velocity t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot Angle vs. Time plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol.t, sol.y[0]) plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') # Phase Portrait plt.subplot(1, 2, 2) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() Advanced Analysis We can extend the model further to include: - Poincar\u00e9 Sections : by sampling state variables at intervals of the driving period - Bifurcation Diagrams : by sweeping over \\(A\\) or \\(\\omega\\) - Lyapunov Exponents : to detect chaotic dynamics Conclusion The forced damped pendulum is a powerful model capturing fundamental and complex behavior in physics. Through theoretical derivations and computational simulations, we observe transitions from order to chaos, and understand deeper mechanisms underlying many real-world dynamic systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating dynamical system that demonstrates a wide range of behaviors from simple harmonic motion to complex chaos. This transition occurs due to the interplay between natural oscillatory forces, damping mechanisms, and external periodic forces. This system provides a classical example for studying phenomena like resonance, energy dissipation, and chaotic dynamics, which are prevalent in many real-world systems such as suspension bridges, climate oscillations, and electronic circuits.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"We begin with the second-order nonlinear differential equation governing a forced damped pendulum: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement - \\(b\\) is the damping coefficient - \\(g\\) is the gravitational acceleration - \\(L\\) is the length of the pendulum - \\(A\\) is the amplitude of the external forcing - \\(\\omega\\) is the driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, \\(\\sin(\\theta) \\approx \\theta\\) , and the equation simplifies to: \\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear differential equation that resembles the driven damped harmonic oscillator.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pure-pendulum-no-damping-or-forcing","text":"\\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = 0 \\]","title":"Pure Pendulum (No damping or forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damped-pendulum-with-damping-no-forcing","text":"\\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = 0 \\]","title":"Damped Pendulum (With damping, no forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driven-undamped-pendulum-with-forcing-no-damping","text":"\\[ \\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\]","title":"Driven Undamped Pendulum (With forcing, no damping)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-full-model","text":"\\[ \\frac{d^2 \\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin(\\theta) = A\\cos(\\omega t) \\]","title":"Forced Damped Pendulum (Full model)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Mechanical Engineering : Suspension systems, rotating machinery Electrical Engineering : Analogies to driven RLC circuits Biomechanics : Modeling of human gait or limb movements under periodic stimulus Climate Science : Oscillatory climate models (e.g., El Nino cycles)","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We use Python to simulate the system dynamics using the Runge-Kutta method. We visualize the angle vs. time, phase portraits, and explore chaotic behavior and resonance.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of external force omega = 2/3 # frequency of external force def pendulum(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions and time span y0 = [0.2, 0.0] # initial angle and angular velocity t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Plot Angle vs. Time plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol.t, sol.y[0]) plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') # Phase Portrait plt.subplot(1, 2, 2) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Diagram') plt.xlabel('Angle (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#advanced-analysis","text":"We can extend the model further to include: - Poincar\u00e9 Sections : by sampling state variables at intervals of the driving period - Bifurcation Diagrams : by sweeping over \\(A\\) or \\(\\omega\\) - Lyapunov Exponents : to detect chaotic dynamics","title":"Advanced Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum is a powerful model capturing fundamental and complex behavior in physics. Through theoretical derivations and computational simulations, we observe transitions from order to chaos, and understand deeper mechanisms underlying many real-world dynamic systems.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Derivation, Simulation, and Application of Kepler's Third Law 1. Introduction The relationship between the orbital period \\(T\\) and the orbital radius \\(r\\) of celestial bodies is described by Kepler's Third Law . It was later derived using Newton's Law of Gravitation , providing a deep connection between gravity and orbital motion. In this document, we: - Derive the relationship mathematically, - Simulate the relation using planetary data, - Calculate the mass of the Earth and Sun using Kepler\u2019s Law, - Discuss the law's application to elliptical orbits. 2. Derivation of Kepler\u2019s Third Law for Circular Orbits Starting with Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] The centripetal force needed for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal (gravity provides centripetal force): \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) relates to velocity \\(v\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\] 3. Simulation and Plotting \\(T^2\\) vs \\(r^3\\) We verify the relationship using planetary data (Mercury, Venus, Earth, Mars). 3.1 Python Code # Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_AU = np.array([0.387, 0.723, 1.000, 1.524]) # Orbital radii (AU) T_years = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital periods (years) # Compute r^3 and T^2 r_cubed = r_AU**3 T_squared = T_years**2 # Plotting plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='blue', markersize=8) for i, planet in enumerate(planets): plt.text(r_cubed[i]*1.02, T_squared[i]*0.98, planet, fontsize=10) plt.xlabel(r\"$r^3$ (AU$^3$)\", fontsize=14) plt.ylabel(r\"$T^2$ (years$^2$)\", fontsize=14) plt.title(r\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=16) plt.grid(True) plt.show() 3.2 Interpretation The plot of \\(T^2\\) against \\(r^3\\) is a straight line , confirming that \\(T^2 \\propto r^3\\) . This matches the theoretical derivation and validates Kepler\u2019s Third Law . 4. Applications: Mass Calculations 4.1 Finding the Mass of the Sun Using Earth's orbit: Orbital radius: \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) Orbital period: \\(T = 3.154 \\times 10^{7}\\ \\text{s}\\) The mass of the Sun is given by: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] where \\(G = 6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) . Code to Find Mass of Sun # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) r_earth = 1.496e11 # Orbital radius of Earth (m) T_earth = 3.154e7 # Orbital period of Earth (s) # Calculate Mass of Sun M_sun = (4 * np.pi**2 * r_earth**3) / (G * T_earth**2) print(f\"Mass of the Sun = {M_sun:.3e} kg\") Result: Mass of the Sun \\(\\approx 1.99 \\times 10^{30}\\ \\text{kg}\\) 4.2 Finding the Mass of the Earth Using the Moon's orbit: Orbital radius: \\(r = 3.844 \\times 10^{8}\\ \\text{m}\\) Orbital period: \\(T = 2.3606 \\times 10^{6}\\ \\text{s}\\) Code to Find Mass of Earth # Moon orbit data r_moon = 3.844e8 # Orbital radius of Moon (m) T_moon = 2.3606e6 # Orbital period of Moon (s) # Calculate Mass of Earth M_earth = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Mass of the Earth = {M_earth:.3e} kg\") Result: Mass of the Earth \\(\\approx 5.97 \\times 10^{24}\\ \\text{kg}\\) 5. Extension: Elliptical Orbits For elliptical orbits, Kepler\u2019s Third Law becomes: \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] where \\(a\\) is the semi-major axis of the ellipse. Thus, \\(T^2\\) is proportional to \\(a^3\\) even for non-circular (elliptical) orbits.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-simulation-and-application-of-keplers-third-law","text":"","title":"Derivation, Simulation, and Application of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-introduction","text":"The relationship between the orbital period \\(T\\) and the orbital radius \\(r\\) of celestial bodies is described by Kepler's Third Law . It was later derived using Newton's Law of Gravitation , providing a deep connection between gravity and orbital motion. In this document, we: - Derive the relationship mathematically, - Simulate the relation using planetary data, - Calculate the mass of the Earth and Sun using Kepler\u2019s Law, - Discuss the law's application to elliptical orbits.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-derivation-of-keplers-third-law-for-circular-orbits","text":"Starting with Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] The centripetal force needed for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting them equal (gravity provides centripetal force): \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) relates to velocity \\(v\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Expanding: \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiplying both sides by \\(r\\) : \\[ 4\\pi^2 r^3 = G M T^2 \\] Finally, solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] Thus: \\[ \\boxed{T^2 \\propto r^3} \\]","title":"2. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-simulation-and-plotting-t2-vs-r3","text":"We verify the relationship using planetary data (Mercury, Venus, Earth, Mars).","title":"3. Simulation and Plotting \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-python-code","text":"# Import necessary libraries import numpy as np import matplotlib.pyplot as plt # Planetary data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] r_AU = np.array([0.387, 0.723, 1.000, 1.524]) # Orbital radii (AU) T_years = np.array([0.241, 0.615, 1.000, 1.881]) # Orbital periods (years) # Compute r^3 and T^2 r_cubed = r_AU**3 T_squared = T_years**2 # Plotting plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, 'o-', color='blue', markersize=8) for i, planet in enumerate(planets): plt.text(r_cubed[i]*1.02, T_squared[i]*0.98, planet, fontsize=10) plt.xlabel(r\"$r^3$ (AU$^3$)\", fontsize=14) plt.ylabel(r\"$T^2$ (years$^2$)\", fontsize=14) plt.title(r\"Kepler's Third Law: $T^2$ vs $r^3$\", fontsize=16) plt.grid(True) plt.show()","title":"3.1 Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-interpretation","text":"The plot of \\(T^2\\) against \\(r^3\\) is a straight line , confirming that \\(T^2 \\propto r^3\\) . This matches the theoretical derivation and validates Kepler\u2019s Third Law .","title":"3.2 Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-applications-mass-calculations","text":"","title":"4. Applications: Mass Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-finding-the-mass-of-the-sun","text":"Using Earth's orbit: Orbital radius: \\(r = 1.496 \\times 10^{11}\\ \\text{m}\\) Orbital period: \\(T = 3.154 \\times 10^{7}\\ \\text{s}\\) The mass of the Sun is given by: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] where \\(G = 6.67430 \\times 10^{-11}\\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) .","title":"4.1 Finding the Mass of the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-to-find-mass-of-sun","text":"# Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) r_earth = 1.496e11 # Orbital radius of Earth (m) T_earth = 3.154e7 # Orbital period of Earth (s) # Calculate Mass of Sun M_sun = (4 * np.pi**2 * r_earth**3) / (G * T_earth**2) print(f\"Mass of the Sun = {M_sun:.3e} kg\") Result: Mass of the Sun \\(\\approx 1.99 \\times 10^{30}\\ \\text{kg}\\)","title":"Code to Find Mass of Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-finding-the-mass-of-the-earth","text":"Using the Moon's orbit: Orbital radius: \\(r = 3.844 \\times 10^{8}\\ \\text{m}\\) Orbital period: \\(T = 2.3606 \\times 10^{6}\\ \\text{s}\\)","title":"4.2 Finding the Mass of the Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#code-to-find-mass-of-earth","text":"# Moon orbit data r_moon = 3.844e8 # Orbital radius of Moon (m) T_moon = 2.3606e6 # Orbital period of Moon (s) # Calculate Mass of Earth M_earth = (4 * np.pi**2 * r_moon**3) / (G * T_moon**2) print(f\"Mass of the Earth = {M_earth:.3e} kg\") Result: Mass of the Earth \\(\\approx 5.97 \\times 10^{24}\\ \\text{kg}\\)","title":"Code to Find Mass of Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-elliptical-orbits","text":"For elliptical orbits, Kepler\u2019s Third Law becomes: \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] where \\(a\\) is the semi-major axis of the ellipse. Thus, \\(T^2\\) is proportional to \\(a^3\\) even for non-circular (elliptical) orbits.","title":"5. Extension: Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape and Cosmic Velocities Introduction Cosmic velocities define the speed thresholds required to: Stay in orbit \u2013 First Cosmic Velocity Escape the planet's gravity \u2013 Second Cosmic Velocity Escape the solar system \u2013 Third Cosmic Velocity These principles are fundamental in spaceflight mechanics and interplanetary mission planning. 1. Derivation of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the minimum speed needed to orbit a celestial body near its surface in a circular orbit. From Newton\u2019s gravitational force and centripetal force balance: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Second Cosmic Velocity ( \\(v_2\\) ) This is the escape velocity , i.e., the velocity needed to completely escape the gravitational field of a planet. From conservation of energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Therefore: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Third Cosmic Velocity ( \\(v_3\\) ) This is the minimum speed required to escape the Sun's gravitational pull from Earth\u2019s orbit. Using Pythagoras-like relation: \\[ v_3 = \\sqrt{v_{\\text{esc, Earth}}^2 + v_{\\text{orbit around Sun}}^2} \\] Where: - \\(v_{\\text{esc, Earth}} \\approx 11.2 \\, \\text{km/s}\\) - \\(v_{\\text{orbit around Sun}} \\approx 29.78 \\, \\text{km/s}\\) Then: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (29.78)^2} \\approx 42.1 \\, \\text{km/s} \\] 2. Earth Cosmic Velocity Values Velocity Type Formula Value (Earth) First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\(\\approx 7.91\\) km/s Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\(\\approx 11.2\\) km/s Third Cosmic Velocity \\(v_3 = \\sqrt{v_1^2 + v_{\\text{orbit}}^2}\\) \\(\\approx 42.1\\) km/s 3. Comparison with Moon, Mars, Jupiter import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Mass (kg) and Radius (m) for each body bodies = { \"Moon\": [7.35e22, 1.74e6], \"Earth\": [5.97e24, 6.37e6], \"Mars\": [6.42e23, 3.39e6], \"Jupiter\": [1.90e27, 6.99e7] } # Calculate v1 and v2 for each body results = {} for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v2 = np.sqrt(2 * G * M / R) / 1000 results[name] = (v1, v2) # Prepare data labels = list(results.keys()) v1_vals = [results[body][0] for body in labels] v2_vals = [results[body][1] for body in labels] # Plot x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') ax.bar(x + width/2, v2_vals, width, label='v2 (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show() Summary Table Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(\\approx 1.68\\) \\(\\approx 2.38\\) Earth \\(\\approx 7.91\\) \\(\\approx 11.2\\) Mars \\(\\approx 3.55\\) \\(\\approx 5.02\\) Jupiter \\(\\approx 42.0\\) \\(\\approx 59.5\\) Applications in Space Science \\(v_1\\) : Needed for low-Earth orbit satellites (e.g., ISS). \\(v_2\\) : Required for missions to the Moon, Mars, or other planets. \\(v_3\\) : Needed for deep-space probes like Voyager or Pioneer missions.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-and-cosmic-velocities","text":"","title":"Escape and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"Cosmic velocities define the speed thresholds required to: Stay in orbit \u2013 First Cosmic Velocity Escape the planet's gravity \u2013 Second Cosmic Velocity Escape the solar system \u2013 Third Cosmic Velocity These principles are fundamental in spaceflight mechanics and interplanetary mission planning.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-derivation-of-cosmic-velocities","text":"","title":"1. Derivation of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the minimum speed needed to orbit a celestial body near its surface in a circular orbit. From Newton\u2019s gravitational force and centripetal force balance: \\[ \\frac{G M m}{R^2} = \\frac{m v_1^2}{R} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"This is the escape velocity , i.e., the velocity needed to completely escape the gravitational field of a planet. From conservation of energy: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Therefore: \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the minimum speed required to escape the Sun's gravitational pull from Earth\u2019s orbit. Using Pythagoras-like relation: \\[ v_3 = \\sqrt{v_{\\text{esc, Earth}}^2 + v_{\\text{orbit around Sun}}^2} \\] Where: - \\(v_{\\text{esc, Earth}} \\approx 11.2 \\, \\text{km/s}\\) - \\(v_{\\text{orbit around Sun}} \\approx 29.78 \\, \\text{km/s}\\) Then: \\[ v_3 \\approx \\sqrt{(11.2)^2 + (29.78)^2} \\approx 42.1 \\, \\text{km/s} \\]","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-earth-cosmic-velocity-values","text":"Velocity Type Formula Value (Earth) First Cosmic Velocity \\(v_1 = \\sqrt{\\frac{G M}{R}}\\) \\(\\approx 7.91\\) km/s Second Cosmic Velocity \\(v_2 = \\sqrt{\\frac{2 G M}{R}}\\) \\(\\approx 11.2\\) km/s Third Cosmic Velocity \\(v_3 = \\sqrt{v_1^2 + v_{\\text{orbit}}^2}\\) \\(\\approx 42.1\\) km/s","title":"2. Earth Cosmic Velocity Values"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-comparison-with-moon-mars-jupiter","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Mass (kg) and Radius (m) for each body bodies = { \"Moon\": [7.35e22, 1.74e6], \"Earth\": [5.97e24, 6.37e6], \"Mars\": [6.42e23, 3.39e6], \"Jupiter\": [1.90e27, 6.99e7] } # Calculate v1 and v2 for each body results = {} for name, (M, R) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 # Convert to km/s v2 = np.sqrt(2 * G * M / R) / 1000 results[name] = (v1, v2) # Prepare data labels = list(results.keys()) v1_vals = [results[body][0] for body in labels] v2_vals = [results[body][1] for body in labels] # Plot x = np.arange(len(labels)) width = 0.35 fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width/2, v1_vals, width, label='v1 (Orbital)') ax.bar(x + width/2, v2_vals, width, label='v2 (Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"3. Comparison with Moon, Mars, Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-table","text":"Body \\(v_1\\) (km/s) \\(v_2\\) (km/s) Moon \\(\\approx 1.68\\) \\(\\approx 2.38\\) Earth \\(\\approx 7.91\\) \\(\\approx 11.2\\) Mars \\(\\approx 3.55\\) \\(\\approx 5.02\\) Jupiter \\(\\approx 42.0\\) \\(\\approx 59.5\\)","title":"Summary Table"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications-in-space-science","text":"\\(v_1\\) : Needed for low-Earth orbit satellites (e.g., ISS). \\(v_2\\) : Required for missions to the Moon, Mars, or other planets. \\(v_3\\) : Needed for deep-space probes like Voyager or Pioneer missions.","title":"Applications in Space Science"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Here is a complete academic solution in Markdown format using LaTeX-style dollar signs for all equations. This includes the explanation, physical modeling, and a Python simulation for Problem 3: Payload Trajectories from Near-Earth Orbit . Trajectories of a Freely Released Payload Near Earth Problem Statement We examine the motion of a payload launched from an altitude of 800 km above Earth's surface with various initial velocities. The goal is to determine whether the object falls back, orbits, or escapes Earth depending on initial conditions. 1. Assumptions and Physical Background Earth's Radius : \\(R_E = 6.37 \\times 10^6 \\, \\text{m}\\) Initial altitude : \\(h = 800 \\, \\text{km} = 8.0 \\times 10^5 \\, \\text{m}\\) Total radial distance : \\(r_0 = R_E + h = 7.17 \\times 10^6 \\, \\text{m}\\) Gravitational Parameter : \\(\\mu = G M_E \\approx 3.986 \\times 10^{14} \\, \\text{m}^3/\\text{s}^2\\) Using Newton's law of gravitation, the equation of motion is: \\[ \\vec{a} = -\\frac{GM_E}{r^3} \\vec{r} \\] This second-order differential equation describes how gravity pulls the object toward Earth. The simulation integrates this numerically using time-stepping. 2. Orbital Behavior vs. Velocity Initial velocities tested: \\[ v_0 = [5,\\, 5.5,\\, 6,\\, 6.5,\\, \\ldots,\\, 13] \\, \\text{km/s} \\] These result in: - \\(v < 7.91\\) km/s : Suborbital (falls back) - \\(v = 7.91\\) km/s : Circular orbit - \\(7.91 < v < 11.2\\) km/s : Elliptical orbit - \\(v = 11.2\\) km/s : Escape velocity - \\(v > 11.2\\) km/s : Hyperbolic trajectory 3. Python Simulation Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg mu = G * M # standard gravitational parameter R_earth = 6.37e6 # Earth's radius in meters altitude = 800e3 # altitude in meters r0 = R_earth + altitude # Time setup dt = 1 # time step in seconds T = 10000 # total time steps = int(T / dt) # Initial velocities in m/s v0_list = np.arange(5e3, 13.5e3, 0.5e3) # Plot setup fig, ax = plt.subplots(figsize=(8, 8)) # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_artist(earth) for v0 in v0_list: pos = np.array([r0, 0.0]) vel = np.array([0.0, v0]) trajectory_x = [] trajectory_y = [] for _ in range(steps): r = np.linalg.norm(pos) acc = -mu * pos / r**3 vel += acc * dt pos += vel * dt trajectory_x.append(pos[0]) trajectory_y.append(pos[1]) if r < R_earth: break ax.plot(trajectory_x, trajectory_y, label=f'{v0/1000:.1f} km/s') # Plot formatting ax.set_title('Trajectories of Payload from 800 km Altitude') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_aspect('equal') ax.set_xlim(-1.5e7, 1.5e7) ax.set_ylim(-1.5e7, 1.5e7) ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() 4. Analysis of Results Initial Velocity (km/s) Trajectory Type 5.0\u20137.9 Suborbital 7.91 Circular Orbit 8.0\u201311.1 Elliptical Orbit 11.2 Escape Trajectory 11.5\u201313.0 Hyperbolic Escape 5. Applications and Implications Understanding these trajectories is essential for: Satellite insertion into LEO or GEO Planetary missions (e.g., Mars rovers) Designing return capsules or interstellar probes Conclusion The velocity at which an object is released significantly determines its trajectory: orbital, escape, or fall-back. These principles form the backbone of trajectory planning in space missions and highlight the delicate balance required for orbital mechanics.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"Here is a complete academic solution in Markdown format using LaTeX-style dollar signs for all equations. This includes the explanation, physical modeling, and a Python simulation for Problem 3: Payload Trajectories from Near-Earth Orbit .","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-statement","text":"We examine the motion of a payload launched from an altitude of 800 km above Earth's surface with various initial velocities. The goal is to determine whether the object falls back, orbits, or escapes Earth depending on initial conditions.","title":"Problem Statement"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-assumptions-and-physical-background","text":"Earth's Radius : \\(R_E = 6.37 \\times 10^6 \\, \\text{m}\\) Initial altitude : \\(h = 800 \\, \\text{km} = 8.0 \\times 10^5 \\, \\text{m}\\) Total radial distance : \\(r_0 = R_E + h = 7.17 \\times 10^6 \\, \\text{m}\\) Gravitational Parameter : \\(\\mu = G M_E \\approx 3.986 \\times 10^{14} \\, \\text{m}^3/\\text{s}^2\\) Using Newton's law of gravitation, the equation of motion is: \\[ \\vec{a} = -\\frac{GM_E}{r^3} \\vec{r} \\] This second-order differential equation describes how gravity pulls the object toward Earth. The simulation integrates this numerically using time-stepping.","title":"1. Assumptions and Physical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-orbital-behavior-vs-velocity","text":"Initial velocities tested: \\[ v_0 = [5,\\, 5.5,\\, 6,\\, 6.5,\\, \\ldots,\\, 13] \\, \\text{km/s} \\] These result in: - \\(v < 7.91\\) km/s : Suborbital (falls back) - \\(v = 7.91\\) km/s : Circular orbit - \\(7.91 < v < 11.2\\) km/s : Elliptical orbit - \\(v = 11.2\\) km/s : Escape velocity - \\(v > 11.2\\) km/s : Hyperbolic trajectory","title":"2. Orbital Behavior vs. Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth in kg mu = G * M # standard gravitational parameter R_earth = 6.37e6 # Earth's radius in meters altitude = 800e3 # altitude in meters r0 = R_earth + altitude # Time setup dt = 1 # time step in seconds T = 10000 # total time steps = int(T / dt) # Initial velocities in m/s v0_list = np.arange(5e3, 13.5e3, 0.5e3) # Plot setup fig, ax = plt.subplots(figsize=(8, 8)) # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) ax.add_artist(earth) for v0 in v0_list: pos = np.array([r0, 0.0]) vel = np.array([0.0, v0]) trajectory_x = [] trajectory_y = [] for _ in range(steps): r = np.linalg.norm(pos) acc = -mu * pos / r**3 vel += acc * dt pos += vel * dt trajectory_x.append(pos[0]) trajectory_y.append(pos[1]) if r < R_earth: break ax.plot(trajectory_x, trajectory_y, label=f'{v0/1000:.1f} km/s') # Plot formatting ax.set_title('Trajectories of Payload from 800 km Altitude') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_aspect('equal') ax.set_xlim(-1.5e7, 1.5e7) ax.set_ylim(-1.5e7, 1.5e7) ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show()","title":"3. Python Simulation Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-analysis-of-results","text":"Initial Velocity (km/s) Trajectory Type 5.0\u20137.9 Suborbital 7.91 Circular Orbit 8.0\u201311.1 Elliptical Orbit 11.2 Escape Trajectory 11.5\u201313.0 Hyperbolic Escape","title":"4. Analysis of Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-applications-and-implications","text":"Understanding these trajectories is essential for: Satellite insertion into LEO or GEO Planetary missions (e.g., Mars rovers) Designing return capsules or interstellar probes","title":"5. Applications and Implications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"The velocity at which an object is released significantly determines its trajectory: orbital, escape, or fall-back. These principles form the backbone of trajectory planning in space missions and highlight the delicate balance required for orbital mechanics.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns from Multiple Wave Sources Overview This document presents a simulation of interference patterns generated by coherent point wave sources located on the vertices of regular polygons. We investigate how the principle of superposition affects wave propagation on a 2D water surface and visualize the resulting waveforms as heatmaps and 3D surface plots . Finally, we produce animated interference videos that capture the wave dynamics over time. 1. Theoretical Background A single wave from a point source is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) at time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source \\((x_0, y_0)\\) , - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase (set to 0 here for simplicity). For \\(N\\) sources at positions \\(\\{(x_i, y_i)\\}\\) , the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . 2. Python Simulation Parameters import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Grid and time x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t_vals = np.linspace(0, 2*np.pi, 60) # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Source configuration: Pentagon def polygon_vertices(N, radius=2): return [(radius * np.cos(2 * np.pi * i / N), radius * np.sin(2 * np.pi * i / N)) for i in range(N)] sources = polygon_vertices(5) # Change to 1, 2, 3... for triangle, square, etc. Wave Function def interference_pattern(X, Y, t, sources): Z = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by zero Z += (A / np.sqrt(R)) * np.cos(k * R - omega * t) return Z 3. Visualization Static 2D and 3D Snapshots # Static at t = 0 Z = interference_pattern(X, Y, t=0, sources=sources) fig = plt.figure(figsize=(12, 5)) # Heatmap ax1 = fig.add_subplot(1, 2, 1) c1 = ax1.imshow(Z, extent=(-5, 5, -5, 5), cmap='seismic') ax1.set_title(\"Heatmap of Interference\") plt.colorbar(c1, ax=ax1) # 3D surface from mpl_toolkits.mplot3d import Axes3D ax2 = fig.add_subplot(1, 2, 2, projection='3d') ax2.plot_surface(X, Y, Z, cmap='viridis', rstride=5, cstride=5) ax2.set_title(\"3D Surface Plot\") plt.tight_layout() plt.show() Animated GIF Creation fig, ax = plt.subplots() im = ax.imshow(np.zeros_like(X), extent=(-5, 5, -5, 5), cmap='seismic', vmin=-3, vmax=3) ax.set_title(\"Wave Interference Animation\") def animate(t): Z = interference_pattern(X, Y, t, sources) im.set_array(Z) return [im] ani = animation.FuncAnimation(fig, animate, frames=t_vals, interval=50, blit=True) ani.save(\"interference.gif\", writer='pillow') 4. Observations and Analysis Single Source : Produces symmetric, concentric waves with uniform intensity loss outward. Two Sources : Creates a clear pattern of nodal (destructive) and antinodal (constructive) lines, known as interference fringes . Multiple Sources (Triangle, Pentagon, etc.) : Introduces complex, symmetric interference patterns with highly structured nodal regions. These become increasingly intricate as the number of sources increases. The coherence of sources ensures stable patterns. Incoherence would blur the interference. 5. Real-World Applications Acoustics : Understanding sound interference in auditoriums. Optics : Multi-slit experiments in wave-particle duality. Telecommunications : Antenna interference and phased arrays. Fluid Mechanics : Wave behavior in oceans and microfluidics. Conclusion This study provides both a mathematical and visual understanding of wave interference using multiple coherent point sources arranged on regular polygons. Such models are foundational for deeper insights in physics and engineering disciplines.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-multiple-wave-sources","text":"","title":"Interference Patterns from Multiple Wave Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#overview","text":"This document presents a simulation of interference patterns generated by coherent point wave sources located on the vertices of regular polygons. We investigate how the principle of superposition affects wave propagation on a 2D water surface and visualize the resulting waveforms as heatmaps and 3D surface plots . Finally, we produce animated interference videos that capture the wave dynamics over time.","title":"Overview"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"A single wave from a point source is modeled by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: - \\(\\eta(x, y, t)\\) is the displacement at point \\((x, y)\\) at time \\(t\\) , - \\(A\\) is the wave amplitude, - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source \\((x_0, y_0)\\) , - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, - \\(\\omega = 2\\pi f\\) is the angular frequency, - \\(\\phi\\) is the phase (set to 0 here for simplicity). For \\(N\\) sources at positions \\(\\{(x_i, y_i)\\}\\) , the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) .","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-python-simulation","text":"","title":"2. Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Grid and time x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) t_vals = np.linspace(0, 2*np.pi, 60) # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Source configuration: Pentagon def polygon_vertices(N, radius=2): return [(radius * np.cos(2 * np.pi * i / N), radius * np.sin(2 * np.pi * i / N)) for i in range(N)] sources = polygon_vertices(5) # Change to 1, 2, 3... for triangle, square, etc.","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-function","text":"def interference_pattern(X, Y, t, sources): Z = np.zeros_like(X) for x0, y0 in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid div by zero Z += (A / np.sqrt(R)) * np.cos(k * R - omega * t) return Z","title":"Wave Function"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-visualization","text":"","title":"3. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#static-2d-and-3d-snapshots","text":"# Static at t = 0 Z = interference_pattern(X, Y, t=0, sources=sources) fig = plt.figure(figsize=(12, 5)) # Heatmap ax1 = fig.add_subplot(1, 2, 1) c1 = ax1.imshow(Z, extent=(-5, 5, -5, 5), cmap='seismic') ax1.set_title(\"Heatmap of Interference\") plt.colorbar(c1, ax=ax1) # 3D surface from mpl_toolkits.mplot3d import Axes3D ax2 = fig.add_subplot(1, 2, 2, projection='3d') ax2.plot_surface(X, Y, Z, cmap='viridis', rstride=5, cstride=5) ax2.set_title(\"3D Surface Plot\") plt.tight_layout() plt.show()","title":"Static 2D and 3D Snapshots"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#animated-gif-creation","text":"fig, ax = plt.subplots() im = ax.imshow(np.zeros_like(X), extent=(-5, 5, -5, 5), cmap='seismic', vmin=-3, vmax=3) ax.set_title(\"Wave Interference Animation\") def animate(t): Z = interference_pattern(X, Y, t, sources) im.set_array(Z) return [im] ani = animation.FuncAnimation(fig, animate, frames=t_vals, interval=50, blit=True) ani.save(\"interference.gif\", writer='pillow')","title":"Animated GIF Creation"},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#4-observations-and-analysis","text":"Single Source : Produces symmetric, concentric waves with uniform intensity loss outward. Two Sources : Creates a clear pattern of nodal (destructive) and antinodal (constructive) lines, known as interference fringes . Multiple Sources (Triangle, Pentagon, etc.) : Introduces complex, symmetric interference patterns with highly structured nodal regions. These become increasingly intricate as the number of sources increases. The coherence of sources ensures stable patterns. Incoherence would blur the interference.","title":"4. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-real-world-applications","text":"Acoustics : Understanding sound interference in auditoriums. Optics : Multi-slit experiments in wave-particle duality. Telecommunications : Antenna interference and phased arrays. Fluid Mechanics : Wave behavior in oceans and microfluidics.","title":"5. Real-World Applications"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This study provides both a mathematical and visual understanding of wave interference using multiple coherent point sources arranged on regular polygons. Such models are foundational for deeper insights in physics and engineering disciplines.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Circuits Problem: Compute Equivalent Resistance Using Graph Theory Introduction Calculating the equivalent resistance between two nodes in a resistor network is fundamental in electrical engineering. As circuits become more complex, traditional simplification using only series and parallel rules becomes inefficient and error-prone. Graph theory offers a systematic , scalable , and automatable approach to this challenge. Graph-Theoretic Approach Modeling the Circuit Vertices (nodes) represent junctions. Edges represent resistors with a weight equal to their resistance value. Objective : Find the equivalent resistance between two distinguished nodes: START and END . Mathematical Tools Graph reduction using simplification rules. Resistor transformations : Series, parallel, and sometimes \u0394\u2013Y (delta-wye) if needed. Traversal methods : DFS/BFS for pathfinding or component detection. Edge contraction and node elimination via Kirchhoff's laws. Problem Setup (Based on Image) Given Circuit We are given the following circuit configuration: Resistors: \\(R_1, R_2, R_4, R_5, R_6, R_7\\) Nodes: START and END Key structures: \\(R_2\\) and \\(R_4\\) are in parallel That parallel block is in series with \\(R_7\\) The block above is in series with two \\(R_6\\) resistors Entire path in parallel with a vertical \\(R_2\\) Entire configuration is in series with \\(R_5\\) between START and END Step-by-Step Reduction Let\u2019s denote resistances: Let\u2019s define: \\(R_2 = x\\) \\(R_4 = y\\) \\(R_6 = z\\) \\(R_5 = a\\) \\(R_7 = b\\) Step 1: Simplify Parallel \\(R_2 \\parallel R_4\\) \\[ R_{24} = \\left( \\frac{1}{R_2} + \\frac{1}{R_4} \\right)^{-1} = \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} \\] Step 2: Add \\(R_7\\) in Series \\[ R_{\\text{lower}} = R_{24} + R_7 = \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\] Step 3: Add Two \\(R_6\\) in Series \\[ R_{66} = 2 \\cdot R_6 = 2z \\] \\[ R_{\\text{stack}} = R_{66} + R_{\\text{lower}} = 2z + \\left( \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\right) \\] Step 4: Put the result in Parallel with \\(R_2\\) (left vertical branch) \\[ R_{\\text{bigparallel}} = \\left( \\frac{1}{x} + \\frac{1}{R_{\\text{stack}}} \\right)^{-1} \\] Step 5: Add \\(R_5\\) in Series to Get Final Resistance \\[ R_{\\text{eq}} = R_5 + R_{\\text{bigparallel}} = a + \\left( \\frac{1}{x} + \\frac{1}{2z + \\left( \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\right)} \\right)^{-1} \\] This is the final equivalent resistance between START and END. Full Pseudocode def equivalent_resistance(x, y, z, a, b): from sympy import symbols, simplify # Step 1: R2 || R4 R24 = 1 / (1 / x + 1 / y) # Step 2: add R7 R_lower = R24 + b # Step 3: R6 + R6 R66 = 2 * z R_stack = R66 + R_lower # Step 4: parallel with vertical R2 R_parallel = 1 / (1 / x + 1 / R_stack) # Step 5: add R5 R_total = a + R_parallel return simplify(R_total) Algorithm Analysis Feature Notes Scalability Efficient for sparse graphs using iterative reduction. Complexity Depends on detection of series/parallel: \\(O(n)\\) to \\(O(n \\log n)\\) . Flexibility Adaptable to graphs with cycles and bridges (e.g., using star-delta).","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits-problem-compute-equivalent-resistance-using-graph-theory","text":"","title":"Circuits Problem: Compute Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating the equivalent resistance between two nodes in a resistor network is fundamental in electrical engineering. As circuits become more complex, traditional simplification using only series and parallel rules becomes inefficient and error-prone. Graph theory offers a systematic , scalable , and automatable approach to this challenge.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-theoretic-approach","text":"","title":"Graph-Theoretic Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#modeling-the-circuit","text":"Vertices (nodes) represent junctions. Edges represent resistors with a weight equal to their resistance value. Objective : Find the equivalent resistance between two distinguished nodes: START and END .","title":"Modeling the Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-tools","text":"Graph reduction using simplification rules. Resistor transformations : Series, parallel, and sometimes \u0394\u2013Y (delta-wye) if needed. Traversal methods : DFS/BFS for pathfinding or component detection. Edge contraction and node elimination via Kirchhoff's laws.","title":"Mathematical Tools"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-setup-based-on-image","text":"","title":"Problem Setup (Based on Image)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#given-circuit","text":"We are given the following circuit configuration: Resistors: \\(R_1, R_2, R_4, R_5, R_6, R_7\\) Nodes: START and END Key structures: \\(R_2\\) and \\(R_4\\) are in parallel That parallel block is in series with \\(R_7\\) The block above is in series with two \\(R_6\\) resistors Entire path in parallel with a vertical \\(R_2\\) Entire configuration is in series with \\(R_5\\) between START and END","title":"Given Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-reduction","text":"Let\u2019s denote resistances: Let\u2019s define: \\(R_2 = x\\) \\(R_4 = y\\) \\(R_6 = z\\) \\(R_5 = a\\) \\(R_7 = b\\)","title":"Step-by-Step Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-simplify-parallel-r_2-parallel-r_4","text":"\\[ R_{24} = \\left( \\frac{1}{R_2} + \\frac{1}{R_4} \\right)^{-1} = \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} \\]","title":"Step 1: Simplify Parallel \\(R_2 \\parallel R_4\\)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-add-r_7-in-series","text":"\\[ R_{\\text{lower}} = R_{24} + R_7 = \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\]","title":"Step 2: Add \\(R_7\\) in Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-add-two-r_6-in-series","text":"\\[ R_{66} = 2 \\cdot R_6 = 2z \\] \\[ R_{\\text{stack}} = R_{66} + R_{\\text{lower}} = 2z + \\left( \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\right) \\]","title":"Step 3: Add Two \\(R_6\\) in Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-4-put-the-result-in-parallel-with-r_2-left-vertical-branch","text":"\\[ R_{\\text{bigparallel}} = \\left( \\frac{1}{x} + \\frac{1}{R_{\\text{stack}}} \\right)^{-1} \\]","title":"Step 4: Put the result in Parallel with \\(R_2\\) (left vertical branch)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-5-add-r_5-in-series-to-get-final-resistance","text":"\\[ R_{\\text{eq}} = R_5 + R_{\\text{bigparallel}} = a + \\left( \\frac{1}{x} + \\frac{1}{2z + \\left( \\left( \\frac{1}{x} + \\frac{1}{y} \\right)^{-1} + b \\right)} \\right)^{-1} \\] This is the final equivalent resistance between START and END.","title":"Step 5: Add \\(R_5\\) in Series to Get Final Resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#full-pseudocode","text":"def equivalent_resistance(x, y, z, a, b): from sympy import symbols, simplify # Step 1: R2 || R4 R24 = 1 / (1 / x + 1 / y) # Step 2: add R7 R_lower = R24 + b # Step 3: R6 + R6 R66 = 2 * z R_stack = R66 + R_lower # Step 4: parallel with vertical R2 R_parallel = 1 / (1 / x + 1 / R_stack) # Step 5: add R5 R_total = a + R_parallel return simplify(R_total)","title":"Full Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-analysis","text":"Feature Notes Scalability Efficient for sparse graphs using iterative reduction. Complexity Depends on detection of series/parallel: \\(O(n)\\) to \\(O(n \\log n)\\) . Flexibility Adaptable to graphs with cycles and bridges (e.g., using star-delta).","title":"Algorithm Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}